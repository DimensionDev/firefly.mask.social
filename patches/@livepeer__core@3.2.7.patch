diff --git a/dist/media/index.cjs b/dist/media/index.cjs
index 059f5bedd9306db2b0b6b4f1185632d722a17fe6..a88f687094839fca44341c467d0fc04ca15f5cd9 100644
--- a/dist/media/index.cjs
+++ b/dist/media/index.cjs
@@ -8,14 +8,18 @@ var __export = (target, all) => {
     __defProp(target, name, { get: all[name], enumerable: true });
 };
 var __copyProps = (to, from, except, desc) => {
-  if (from && typeof from === "object" || typeof from === "function") {
+  if ((from && typeof from === "object") || typeof from === "function") {
     for (let key of __getOwnPropNames(from))
       if (!__hasOwnProp.call(to, key) && key !== except)
-        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+        __defProp(to, key, {
+          get: () => from[key],
+          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
+        });
   }
   return to;
 };
-var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+var __toCommonJS = (mod) =>
+  __copyProps(__defProp({}, "__esModule", { value: true }), mod);
 
 // src/media.ts
 var media_exports = {};
@@ -25,7 +29,7 @@ __export(media_exports, {
   calculateVideoQualityDimensions: () => calculateVideoQualityDimensions,
   createControllerStore: () => createControllerStore,
   getBoundedVolume: () => getBoundedVolume,
-  getMediaSourceType: () => getMediaSourceType
+  getMediaSourceType: () => getMediaSourceType,
 });
 module.exports = __toCommonJS(media_exports);
 
@@ -37,15 +41,25 @@ var import_vanilla = require("zustand/vanilla");
 var STREAM_OPEN_ERROR_MESSAGE = "stream open failed";
 var STREAM_OFFLINE_ERROR_MESSAGE = "stream is offline";
 var STREAM_WAITING_FOR_DATA_ERROR_MESSAGE = "stream is waiting for data";
-var ACCESS_CONTROL_ERROR_MESSAGE = "shutting down since this session is not allowed to view this stream";
-var BFRAMES_ERROR_MESSAGE = "metadata indicates that webrtc playback contains bframes";
-var NOT_ACCEPTABLE_ERROR_MESSAGE = "response indicates unacceptable playback protocol";
+var ACCESS_CONTROL_ERROR_MESSAGE =
+  "shutting down since this session is not allowed to view this stream";
+var BFRAMES_ERROR_MESSAGE =
+  "metadata indicates that webrtc playback contains bframes";
+var NOT_ACCEPTABLE_ERROR_MESSAGE =
+  "response indicates unacceptable playback protocol";
 var PERMISSIONS_ERROR_MESSAGE = "user did not allow the permissions request";
-var isStreamOfflineError = (error) => error.message.toLowerCase().includes(STREAM_OPEN_ERROR_MESSAGE) || error.message.toLowerCase().includes(STREAM_WAITING_FOR_DATA_ERROR_MESSAGE) || error.message.toLowerCase().includes(STREAM_OFFLINE_ERROR_MESSAGE);
-var isAccessControlError = (error) => error.message.toLowerCase().includes(ACCESS_CONTROL_ERROR_MESSAGE);
-var isBframesError = (error) => error.message.toLowerCase().includes(BFRAMES_ERROR_MESSAGE);
-var isNotAcceptableError = (error) => error.message.toLowerCase().includes(NOT_ACCEPTABLE_ERROR_MESSAGE);
-var isPermissionsError = (error) => error.message.toLowerCase().includes(PERMISSIONS_ERROR_MESSAGE);
+var isStreamOfflineError = (error) =>
+  error.message.toLowerCase().includes(STREAM_OPEN_ERROR_MESSAGE) ||
+  error.message.toLowerCase().includes(STREAM_WAITING_FOR_DATA_ERROR_MESSAGE) ||
+  error.message.toLowerCase().includes(STREAM_OFFLINE_ERROR_MESSAGE);
+var isAccessControlError = (error) =>
+  error.message.toLowerCase().includes(ACCESS_CONTROL_ERROR_MESSAGE);
+var isBframesError = (error) =>
+  error.message.toLowerCase().includes(BFRAMES_ERROR_MESSAGE);
+var isNotAcceptableError = (error) =>
+  error.message.toLowerCase().includes(NOT_ACCEPTABLE_ERROR_MESSAGE);
+var isPermissionsError = (error) =>
+  error.message.toLowerCase().includes(PERMISSIONS_ERROR_MESSAGE);
 
 // src/media/utils.ts
 var import_nanoid = require("nanoid");
@@ -54,7 +68,7 @@ var import_nanoid = require("nanoid");
 var getMetricsReportingPOSTUrl = async (opts) => {
   const resolvedReportingUrl = await getMetricsReportingUrl({
     playbackUrl: opts.playbackUrl,
-    path: "/analytics/log"
+    path: "/analytics/log",
   });
   if (!resolvedReportingUrl) {
     return null;
@@ -67,7 +81,7 @@ var getMetricsReportingWebsocketUrl = async (opts) => {
   }
   const resolvedReportingUrl = await getMetricsReportingUrl({
     playbackUrl: opts.playbackUrl,
-    path: `/json_video+${opts.playbackId}.js`
+    path: `/json_video+${opts.playbackId}.js`,
   });
   if (!resolvedReportingUrl) {
     return null;
@@ -79,10 +93,7 @@ var getMetricsReportingWebsocketUrl = async (opts) => {
   return resolvedReportingUrl?.toString?.() ?? null;
 };
 var LP_DOMAINS = ["livepeer", "livepeercdn", "lp-playback"];
-var getMetricsReportingUrl = async ({
-  playbackUrl,
-  path
-}) => {
+var getMetricsReportingUrl = async ({ playbackUrl, path }) => {
   try {
     const parsedPlaybackUrl = new URL(playbackUrl);
     const splitHost = parsedPlaybackUrl.host.split(".");
@@ -90,7 +101,16 @@ var getMetricsReportingUrl = async ({
       splitHost?.[splitHost.length - 2] ?? ""
     );
     const tld = splitHost?.[splitHost?.length - 1] ?? null;
-    const tldMapped = tld === "com" ? "studio" : tld === "studio" ? "studio" : tld === "fun" ? "fun:20443" : tld === "monster" ? "monster" : null;
+    const tldMapped =
+      tld === "com"
+        ? "studio"
+        : tld === "studio"
+        ? "studio"
+        : tld === "fun"
+        ? "fun:20443"
+        : tld === "monster"
+        ? "monster"
+        : null;
     if (includesDomain && tldMapped) {
       const isCatalystPlayback = parsedPlaybackUrl.host.includes("catalyst");
       try {
@@ -101,7 +121,9 @@ var getMetricsReportingUrl = async ({
           await response.text();
           return response?.url ?? null;
         };
-        const finalUrl = isCatalystPlayback ? `https://${parsedPlaybackUrl.host}${path}` : await getRedirectedUrl();
+        const finalUrl = isCatalystPlayback
+          ? `https://${parsedPlaybackUrl.host}${path}`
+          : await getRedirectedUrl();
         const url = finalUrl ? new URL(finalUrl) : null;
         return url ?? null;
       } catch (error) {
@@ -125,7 +147,12 @@ var getPlaybackIdFromSourceUrl = (sourceUrl) => {
   const includesWebRtcUrl = parts.includes(WEBRTC_URL_PART_VALUE);
   const includesFlvUrl = parts.includes(FLV_URL_PART_VALUE);
   const includesRecording = parts.includes(RECORDING_URL_PART_VALUE);
-  const playbackId = includesWebRtcUrl || includesFlvUrl ? parts?.[(parts?.length ?? 0) - 1] : includesRecording || includesAssetUrl ? parts?.[(parts?.length ?? 0) - 2] ?? null : null;
+  const playbackId =
+    includesWebRtcUrl || includesFlvUrl
+      ? parts?.[(parts?.length ?? 0) - 1]
+      : includesRecording || includesAssetUrl
+      ? parts?.[(parts?.length ?? 0) - 2] ?? null
+      : null;
   if (playbackId?.includes("+")) {
     const split = playbackId.split("+")?.[1];
     if (split) {
@@ -229,11 +256,12 @@ var mime = {
   "video/x-ms-wvx": ["wvx"],
   "video/x-msvideo": ["avi"],
   "video/x-sgi-movie": ["movie"],
-  "video/x-smv": ["smv"]
+  "video/x-smv": ["smv"],
 };
 
 // src/media/src.ts
-var audioExtensions = /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
+var audioExtensions =
+  /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
 var base64String = /data:video/i;
 var hlsExtensions = /\.(m3u8)($|\?)/i;
 var flvExtensions = /\/(flv)\//i;
@@ -250,77 +278,94 @@ var getMediaSourceType = (src, opts) => {
   const base64Mime = sourceTest.match(mimeFromBase64Pattern);
   const resolvedWidth = opts?.sizing?.width ?? null;
   const resolvedHeight = opts?.sizing?.height ?? null;
-  return webrtcExtensions.test(sourceTest) ? {
-    type: "webrtc",
-    src,
-    mime: "video/h264",
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : hlsExtensions.test(sourceTest) ? {
-    type: "hls",
-    src,
-    mime: getMimeType(hlsExtensions.exec(sourceTest)?.[1] ?? ""),
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : videoExtensions.test(sourceTest) ? {
-    type: "video",
-    src,
-    mime: getMimeType(videoExtensions.exec(sourceTest)?.[1] ?? ""),
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : audioExtensions.test(sourceTest) ? {
-    type: "audio",
-    src,
-    mime: getMimeType(audioExtensions.exec(sourceTest)?.[1] ?? ""),
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : base64String.test(sourceTest) ? {
-    type: "video",
-    src,
-    mime: base64Mime ? base64Mime[1] : "video/mp4",
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : imageExtensions.test(sourceTest) ? {
-    type: "image",
-    src,
-    mime: getMimeType(
-      imageExtensions.exec(sourceTest)?.[1] ?? ""
-    ),
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : vttExtensions.test(sourceTest) ? {
-    type: "vtt",
-    src,
-    mime: getMimeType(
-      vttExtensions.exec(sourceTest)?.[1] ?? ""
-    ),
-    width: null,
-    height: null
-  } : flvExtensions.test(sourceTest) ? {
-    type: "video",
-    src,
-    mime: "video/x-flv",
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : null;
+  return webrtcExtensions.test(sourceTest)
+    ? {
+        type: "webrtc",
+        src,
+        mime: "video/h264",
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : hlsExtensions.test(sourceTest)
+    ? {
+        type: "hls",
+        src,
+        mime: getMimeType(hlsExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : videoExtensions.test(sourceTest)
+    ? {
+        type: "video",
+        src,
+        mime: getMimeType(videoExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : audioExtensions.test(sourceTest)
+    ? {
+        type: "audio",
+        src,
+        mime: getMimeType(audioExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : base64String.test(sourceTest)
+    ? {
+        type: "video",
+        src,
+        mime: base64Mime ? base64Mime[1] : "video/mp4",
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : imageExtensions.test(sourceTest)
+    ? {
+        type: "image",
+        src,
+        mime: getMimeType(imageExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : vttExtensions.test(sourceTest)
+    ? {
+        type: "vtt",
+        src,
+        mime: getMimeType(vttExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: null,
+        height: null,
+      }
+    : flvExtensions.test(sourceTest)
+    ? {
+        type: "video",
+        src,
+        mime: "video/x-flv",
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : null;
 };
 
 // src/media/utils.ts
 var DEFAULT_ASPECT_RATIO = 16 / 9;
-var getFilteredNaN = (value) => value && !Number.isNaN(value) && Number.isFinite(value) ? value : 0;
-var getBoundedSeek = (seek, duration) => Math.min(
-  Math.max(0, getFilteredNaN(seek)),
-  // seek to near the end
-  getFilteredNaN(duration) ? getFilteredNaN(duration) - 0.01 : 0
-);
+var getFilteredNaN = (value) =>
+  value && !Number.isNaN(value) && Number.isFinite(value) ? value : 0;
+var getBoundedSeek = (seek, duration) =>
+  Math.min(
+    Math.max(0, getFilteredNaN(seek)),
+    // seek to near the end
+    getFilteredNaN(duration) ? getFilteredNaN(duration) - 0.01 : 0
+  );
 var getBoundedRate = (rate) => {
   if (typeof rate === "number") {
     return Math.min(Math.max(0, getFilteredNaN(rate)), 20);
   }
   const match = String(rate).match(/(\d+(\.\d+)?)/);
-  return match ? Math.min(Math.max(0, getFilteredNaN(Number.parseFloat(match[0]))), 20) : 1;
+  return match
+    ? Math.min(Math.max(0, getFilteredNaN(Number.parseFloat(match[0]))), 20)
+    : 1;
 };
-var getBoundedVolume = (volume) => Math.min(Math.max(0, getFilteredNaN(volume)), 1);
+var getBoundedVolume = (volume) =>
+  Math.min(Math.max(0, getFilteredNaN(volume)), 1);
 var nanoid = (0, import_nanoid.customAlphabet)(
   "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
   22
@@ -328,38 +373,42 @@ var nanoid = (0, import_nanoid.customAlphabet)(
 var generateRandomToken = () => {
   return nanoid();
 };
-var getClipParams = ({
-  requestedTime,
-  clipLength,
-  playbackOffsetMs
-}) => {
+var getClipParams = ({ requestedTime, clipLength, playbackOffsetMs }) => {
   const currentTime = requestedTime ?? Date.now();
   const estimatedServerClipTime = currentTime - (playbackOffsetMs ?? 0);
   const startTime = estimatedServerClipTime - clipLength * 1e3;
   const endTime = estimatedServerClipTime;
   return {
     startTime,
-    endTime
+    endTime,
   };
 };
-var getProgressAria = ({
-  progress,
-  duration,
-  live
-}) => {
+var getProgressAria = ({ progress, duration, live }) => {
   const progressParsed = getHoursMinutesSeconds(progress ?? null);
   const durationParsed = getHoursMinutesSeconds(duration ?? null);
-  const progressText = `${progressParsed.hours ? `${progressParsed.hours} hours ` : ""}${progressParsed.minutes ? `${progressParsed.minutes} minutes ` : ""}${progressParsed.seconds ? `${progressParsed.seconds} seconds` : ""}`;
-  const durationText = `${durationParsed.hours ? `${durationParsed.hours} hours ` : ""}${durationParsed.minutes ? `${durationParsed.minutes} minutes ` : ""}${durationParsed.seconds ? `${durationParsed.seconds} seconds` : ""}`;
-  const progressDisplay = live ? `Live ${progressText}` : `${progressText} of ${durationText}`;
+  const progressText = `${
+    progressParsed.hours ? `${progressParsed.hours} hours ` : ""
+  }${progressParsed.minutes ? `${progressParsed.minutes} minutes ` : ""}${
+    progressParsed.seconds ? `${progressParsed.seconds} seconds` : ""
+  }`;
+  const durationText = `${
+    durationParsed.hours ? `${durationParsed.hours} hours ` : ""
+  }${durationParsed.minutes ? `${durationParsed.minutes} minutes ` : ""}${
+    durationParsed.seconds ? `${durationParsed.seconds} seconds` : ""
+  }`;
+  const progressDisplay = live
+    ? `Live ${progressText}`
+    : `${progressText} of ${durationText}`;
   const formattedTimeDisplay = getFormattedHoursMinutesSeconds(
     progress ?? null
   );
   const formattedDuration = getFormattedHoursMinutesSeconds(duration ?? null);
-  const formattedTime = live ? formattedTimeDisplay : `${formattedTimeDisplay} / ${formattedDuration}`;
+  const formattedTime = live
+    ? formattedTimeDisplay
+    : `${formattedTimeDisplay} / ${formattedDuration}`;
   return {
     progress: progressDisplay,
-    time: formattedTime
+    time: formattedTime,
   };
 };
 var sortSources = ({
@@ -368,7 +417,7 @@ var sortSources = ({
   screenWidth,
   aspectRatio,
   lowLatency,
-  hasRecentWebRTCTimeout
+  hasRecentWebRTCTimeout,
 }) => {
   if (!src) {
     return null;
@@ -377,40 +426,63 @@ var sortSources = ({
     const mediaSourceType = getMediaSourceType(src);
     return mediaSourceType ? [mediaSourceType] : null;
   }
-  const filteredVideoSources = src.filter(
-    (s) => s.type === "audio" || s.type === "hls" || s.type === "webrtc" || s.type === "video"
-  ).filter((s) => {
-    if (s.type === "hls" && lowLatency === "force") {
-      return false;
-    }
-    if (s.type === "webrtc" && (lowLatency === false || hasRecentWebRTCTimeout)) {
-      return false;
-    }
-    return true;
-  });
+  const filteredVideoSources = src
+    .filter(
+      (s) =>
+        s.type === "audio" ||
+        s.type === "hls" ||
+        s.type === "webrtc" ||
+        s.type === "video"
+    )
+    .filter((s) => {
+      if (s.type === "hls" && lowLatency === "force") {
+        return false;
+      }
+      if (
+        s.type === "webrtc" &&
+        (lowLatency === false || hasRecentWebRTCTimeout)
+      ) {
+        return false;
+      }
+      return true;
+    });
   const videoQualityDimensions = calculateVideoQualityDimensions(
     videoQuality,
     aspectRatio
   );
   const targetWidth = videoQualityDimensions?.width ?? screenWidth ?? 1280;
-  const sourceWithParentDelta = filteredVideoSources?.map(
-    (s) => s.type === "hls" || s.type === "webrtc" ? { ...s, parentWidthDelta: null } : {
-      ...s,
-      parentWidthDelta: (
-        // first we check if the URL contains the video quality selector
-        videoQuality && videoQuality !== "auto" && s?.src?.includes(videoQuality) ? 0 : (
-          // otherwise use the width of the src
-          s?.width ? Math.abs(targetWidth - s.width) : (
-            // otherwise guess the width of the src based on the url
-            s?.src.includes("static360p") || s?.src.includes("low-bitrate") ? Math.abs(targetWidth - 480) : s?.src.includes("static720p") ? Math.abs(targetWidth - 1280) : s?.src.includes("static1080p") ? Math.abs(targetWidth - 1920) : s?.src.includes("static2160p") ? Math.abs(targetWidth - 3840) : null
-          )
-        )
-      )
-    }
-  ) ?? [];
+  const sourceWithParentDelta =
+    filteredVideoSources?.map((s) =>
+      s.type === "hls" || s.type === "webrtc"
+        ? { ...s, parentWidthDelta: null }
+        : {
+            ...s,
+            parentWidthDelta:
+              // first we check if the URL contains the video quality selector
+              videoQuality &&
+              videoQuality !== "auto" &&
+              s?.src?.includes(videoQuality)
+                ? 0
+                : // otherwise use the width of the src
+                s?.width
+                ? Math.abs(targetWidth - s.width)
+                : // otherwise guess the width of the src based on the url
+                s?.src.includes("static360p") || s?.src.includes("low-bitrate")
+                ? Math.abs(targetWidth - 480)
+                : s?.src.includes("static720p")
+                ? Math.abs(targetWidth - 1280)
+                : s?.src.includes("static1080p")
+                ? Math.abs(targetWidth - 1920)
+                : s?.src.includes("static2160p")
+                ? Math.abs(targetWidth - 3840)
+                : null,
+          }
+    ) ?? [];
   const sortedSources = sourceWithParentDelta.sort((a, b) => {
     if (a.type === "video" && b.type === "video") {
-      return b?.parentWidthDelta !== null && a?.parentWidthDelta !== null ? a.parentWidthDelta - b.parentWidthDelta : 1;
+      return b?.parentWidthDelta !== null && a?.parentWidthDelta !== null
+        ? a.parentWidthDelta - b.parentWidthDelta
+        : 1;
     }
     if (a.type === "video" && (b.type === "hls" || b.type === "webrtc")) {
       return -1;
@@ -430,14 +502,15 @@ var parseCurrentSourceAndPlaybackId = ({
   jwt,
   sessionToken,
   source,
-  videoQuality
+  videoQuality,
+  forceNoToken,
 }) => {
   if (!source) {
     return null;
   }
   const playbackId = getPlaybackIdFromSourceUrl(source.src);
   const url = new URL(source.src);
-  if (sessionToken) {
+  if (sessionToken && !forceNoToken) {
     url.searchParams.append("tkn", sessionToken);
   }
   if (source.type !== "webrtc" && source.type !== "hls") {
@@ -461,15 +534,18 @@ var parseCurrentSourceAndPlaybackId = ({
   }
   const newSrc = {
     ...source,
-    src: url.toString()
+    src: url.toString(),
   };
-  const videoSourceIfHlsUnsupported = newSrc?.type === "hls" && !isHlsSupported ? {
-    ...newSrc,
-    type: "video"
-  } : newSrc;
+  const videoSourceIfHlsUnsupported =
+    newSrc?.type === "hls" && !isHlsSupported
+      ? {
+          ...newSrc,
+          type: "video",
+        }
+      : newSrc;
   return {
     currentSource: videoSourceIfHlsUnsupported,
-    playbackId
+    playbackId,
   };
 };
 var getNewSource = ({
@@ -483,7 +559,8 @@ var getNewSource = ({
   sessionToken,
   src,
   videoQuality,
-  hasRecentWebRTCTimeout
+  hasRecentWebRTCTimeout,
+  forceNoToken,
 }) => {
   const sortedSources = sortSources({
     src,
@@ -491,7 +568,7 @@ var getNewSource = ({
     videoQuality,
     aspectRatio: aspectRatio ?? DEFAULT_ASPECT_RATIO,
     lowLatency,
-    hasRecentWebRTCTimeout
+    hasRecentWebRTCTimeout,
   });
   const parsedSource = parseCurrentSourceAndPlaybackId({
     accessKey: accessKey ?? null,
@@ -501,12 +578,13 @@ var getNewSource = ({
     playbackRate,
     sessionToken,
     source: sortedSources?.[0] ?? null,
-    videoQuality
+    videoQuality,
+    forceNoToken,
   });
   return {
     currentSource: parsedSource?.currentSource ?? null,
     playbackId: parsedSource?.playbackId ?? null,
-    sortedSources
+    sortedSources,
   };
 };
 var getVideoTrackSelectorForQuality = (videoQuality, aspectRatio) => {
@@ -523,46 +601,75 @@ var getVideoTrackSelectorForQuality = (videoQuality, aspectRatio) => {
   return null;
 };
 function calculateVideoQualityDimensions(videoQuality, aspectRatio) {
-  const height = videoQuality === "1080p" ? 1080 : videoQuality === "720p" ? 720 : videoQuality === "480p" ? 480 : videoQuality === "360p" ? 360 : videoQuality === "240p" ? 240 : videoQuality === "144p" ? 144 : null;
+  const height =
+    videoQuality === "1080p"
+      ? 1080
+      : videoQuality === "720p"
+      ? 720
+      : videoQuality === "480p"
+      ? 480
+      : videoQuality === "360p"
+      ? 360
+      : videoQuality === "240p"
+      ? 240
+      : videoQuality === "144p"
+      ? 144
+      : null;
   return {
-    width: height !== null ? Math.round(height * (aspectRatio ?? 16 / 9)) : null,
-    height
+    width:
+      height !== null ? Math.round(height * (aspectRatio ?? 16 / 9)) : null,
+    height,
   };
 }
 var getFormattedHoursMinutesSeconds = (valueInSeconds) => {
   const hoursMinutesSeconds = getHoursMinutesSeconds(valueInSeconds);
-  if (hoursMinutesSeconds.seconds || hoursMinutesSeconds.minutes || hoursMinutesSeconds.hours) {
+  if (
+    hoursMinutesSeconds.seconds ||
+    hoursMinutesSeconds.minutes ||
+    hoursMinutesSeconds.hours
+  ) {
     if (hoursMinutesSeconds.hours > 0) {
-      return `${hoursMinutesSeconds.hours}:${hoursMinutesSeconds.minutes.toString().padStart(2, "0")}:${hoursMinutesSeconds.seconds < 10 ? "0" : ""}${hoursMinutesSeconds.seconds}`;
+      return `${hoursMinutesSeconds.hours}:${hoursMinutesSeconds.minutes
+        .toString()
+        .padStart(2, "0")}:${hoursMinutesSeconds.seconds < 10 ? "0" : ""}${
+        hoursMinutesSeconds.seconds
+      }`;
     }
-    return `${hoursMinutesSeconds.minutes}:${hoursMinutesSeconds.seconds.toString().padStart(2, "0")}`;
+    return `${hoursMinutesSeconds.minutes}:${hoursMinutesSeconds.seconds
+      .toString()
+      .padStart(2, "0")}`;
   }
   return "0:00";
 };
 var getHoursMinutesSeconds = (valueInSeconds) => {
-  if (valueInSeconds !== void 0 && valueInSeconds !== null && !Number.isNaN(valueInSeconds) && Number.isFinite(valueInSeconds)) {
+  if (
+    valueInSeconds !== void 0 &&
+    valueInSeconds !== null &&
+    !Number.isNaN(valueInSeconds) &&
+    Number.isFinite(valueInSeconds)
+  ) {
     const roundedValue = Math.round(valueInSeconds);
     const hours = Math.floor(roundedValue / 3600);
     const seconds = Math.floor(roundedValue % 60);
     if (hours > 0) {
-      const minutes2 = Math.floor(roundedValue % 3600 / 60);
+      const minutes2 = Math.floor((roundedValue % 3600) / 60);
       return {
         hours,
         minutes: minutes2,
-        seconds
+        seconds,
       };
     }
     const minutes = Math.floor(roundedValue / 60);
     return {
       hours: 0,
       minutes,
-      seconds
+      seconds,
     };
   }
   return {
     hours: 0,
     minutes: 0,
-    seconds: 0
+    seconds: 0,
   };
 };
 
@@ -580,7 +687,7 @@ var createControllerStore = ({
   storage,
   src,
   initialProps,
-  playbackId
+  playbackId,
 }) => {
   const initialPlaybackRate = initialProps?.playbackRate ?? 1;
   const initialVolume = getBoundedVolume(
@@ -588,7 +695,8 @@ var createControllerStore = ({
   );
   const initialVideoQuality = initialProps.videoQuality ?? "auto";
   const sessionToken = generateRandomToken();
-  const thumbnailSrc = typeof src === "string" ? null : src?.find?.((s) => s.type === "image");
+  const thumbnailSrc =
+    typeof src === "string" ? null : src?.find?.((s) => s.type === "image");
   const lowLatency = initialProps.lowLatency ?? true;
   const parsedInputSource = getNewSource({
     accessKey: initialProps?.accessKey,
@@ -603,7 +711,8 @@ var createControllerStore = ({
     videoQuality: initialVideoQuality,
     hasRecentWebRTCTimeout: getHasRecentWebRTCTimeout(
       initialProps.cacheWebRTCFailureMs
-    )
+    ),
+    forceNoToken: initialProps?.forceNoToken,
   });
   const initialControls = {
     hlsConfig: null,
@@ -624,7 +733,7 @@ var createControllerStore = ({
     sessionToken,
     size: null,
     thumbnail: thumbnailSrc ?? null,
-    volume: initialVolume
+    volume: initialVolume,
   };
   const store = (0, import_vanilla.createStore)(
     (0, import_middleware.subscribeWithSelector)(
@@ -675,10 +784,12 @@ var createControllerStore = ({
             fullscreen: "Full screen (f)",
             pictureInPicture: "Mini player (i)",
             playPause: "Play (k)",
-            clip: initialProps.clipLength ? `Clip last ${Number(initialProps.clipLength).toFixed(
-              0
-            )} seconds (x)` : null,
-            time: "0:00"
+            clip: initialProps.clipLength
+              ? `Clip last ${Number(initialProps.clipLength).toFixed(
+                  0
+                )} seconds (x)`
+              : null,
+            time: "0:00",
           },
           __initialProps: {
             accessKey: initialProps.accessKey ?? null,
@@ -687,6 +798,7 @@ var createControllerStore = ({
             backoff: Math.max(initialProps.backoff ?? 500, 100),
             backoffMax: Math.max(initialProps.backoffMax ?? 3e4, 1e4),
             clipLength: initialProps.clipLength ?? null,
+            forceNoToken: initialProps.forceNoToken ?? false,
             cacheWebRTCFailureMs: initialProps.cacheWebRTCFailureMs ?? null,
             hotkeys: initialProps?.hotkeys ?? true,
             jwt: initialProps.jwt ?? null,
@@ -699,93 +811,105 @@ var createControllerStore = ({
             timeout: initialProps.timeout ?? 1e4,
             videoQuality: initialVideoQuality,
             viewerId: initialProps.viewerId ?? null,
-            volume: initialVolume ?? null
+            volume: initialVolume ?? null,
           },
           __device: device,
           __controls: initialControls,
           __metadata: null,
           __controlsFunctions: {
-            setMounted: () => set(() => ({
-              mounted: true
-            })),
-            setPoster: (poster) => set(() => ({
-              poster
-            })),
-            setMetricsReportingUrl: (metricsReportingUrl) => set(() => ({
-              metricsReportingUrl
-            })),
+            setMounted: () =>
+              set(() => ({
+                mounted: true,
+              })),
+            setPoster: (poster) =>
+              set(() => ({
+                poster,
+              })),
+            setMetricsReportingUrl: (metricsReportingUrl) =>
+              set(() => ({
+                metricsReportingUrl,
+              })),
             onWebRTCTimeout: () => {
               webrtcTimeoutLastTime = Date.now();
             },
-            setAutohide: (autohide) => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                autohide
-              }
-            })),
-            setHlsConfig: (hlsConfig) => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                hlsConfig
-              }
-            })),
-            setHidden: (hidden) => set(({ playing }) => ({
-              hidden: playing ? hidden : false
-            })),
-            updateLastInteraction: () => set(({ __controls }) => ({
-              __controls: { ...__controls, lastInteraction: Date.now() }
-            })),
-            updatePlaybackOffsetMs: (offset) => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                playbackOffsetMs: offset
-              }
-            })),
-            onCanPlay: () => set(() => ({
-              canPlay: true,
-              loading: false
-            })),
-            onPlay: () => set(({ aria, __controls, __controlsFunctions }) => {
-              __controlsFunctions.onError(null);
-              const title = "Pause (k)";
-              return {
-                playing: true,
-                hasPlayed: true,
-                error: null,
-                errorCount: 0,
-                stalled: false,
-                waiting: false,
-                ended: false,
+            setAutohide: (autohide) =>
+              set(({ __controls }) => ({
                 __controls: {
                   ...__controls,
-                  playLastTime: Date.now()
+                  autohide,
                 },
-                aria: {
-                  ...aria,
-                  playPause: title
-                }
-              };
-            }),
-            onPause: () => set(({ aria, __controls }) => {
-              const title = "Play (k)";
-              return {
-                playing: false,
-                hidden: false,
-                stalled: false,
-                waiting: false,
-                ended: false,
-                aria: {
-                  ...aria,
-                  playPause: title
+              })),
+            setHlsConfig: (hlsConfig) =>
+              set(({ __controls }) => ({
+                __controls: {
+                  ...__controls,
+                  hlsConfig,
                 },
+              })),
+            setHidden: (hidden) =>
+              set(({ playing }) => ({
+                hidden: playing ? hidden : false,
+              })),
+            updateLastInteraction: () =>
+              set(({ __controls }) => ({
+                __controls: { ...__controls, lastInteraction: Date.now() },
+              })),
+            updatePlaybackOffsetMs: (offset) =>
+              set(({ __controls }) => ({
                 __controls: {
                   ...__controls,
-                  pauseLastTime: Date.now()
-                }
-              };
-            }),
+                  playbackOffsetMs: offset,
+                },
+              })),
+            onCanPlay: () =>
+              set(() => ({
+                canPlay: true,
+                loading: false,
+              })),
+            onPlay: () =>
+              set(({ aria, __controls, __controlsFunctions }) => {
+                __controlsFunctions.onError(null);
+                const title = "Pause (k)";
+                return {
+                  playing: true,
+                  hasPlayed: true,
+                  error: null,
+                  errorCount: 0,
+                  stalled: false,
+                  waiting: false,
+                  ended: false,
+                  __controls: {
+                    ...__controls,
+                    playLastTime: Date.now(),
+                  },
+                  aria: {
+                    ...aria,
+                    playPause: title,
+                  },
+                };
+              }),
+            onPause: () =>
+              set(({ aria, __controls }) => {
+                const title = "Play (k)";
+                return {
+                  playing: false,
+                  hidden: false,
+                  stalled: false,
+                  waiting: false,
+                  ended: false,
+                  aria: {
+                    ...aria,
+                    playPause: title,
+                  },
+                  __controls: {
+                    ...__controls,
+                    pauseLastTime: Date.now(),
+                  },
+                };
+              }),
             togglePlay: (force) => {
-              const { hidden, __device, __controlsFunctions } = store.getState();
+              const { hidden, __device, __controlsFunctions } =
+                store.getState();
               if (!force && hidden && __device.isMobile) {
                 __controlsFunctions.setHidden(false);
               } else {
@@ -793,288 +917,358 @@ var createControllerStore = ({
                   __controls: {
                     ...__controls,
                     requestedPlayPauseLastTime: Date.now(),
-                    lastInteraction: Date.now()
-                  }
+                    lastInteraction: Date.now(),
+                  },
                 }));
               }
             },
-            onProgress: (time) => set(({ aria, progress, duration, live }) => {
-              const progressAria = getProgressAria({
-                progress,
-                duration,
-                live
-              });
-              const playPauseTitle = "Pause (k)";
-              return {
-                aria: {
-                  ...aria,
-                  progress: progressAria.progress,
-                  time: progressAria.time,
-                  playPause: playPauseTitle
-                },
-                progress: getFilteredNaN(time),
-                waiting: false,
-                stalled: false,
-                ended: false
-              };
-            }),
-            requestSeek: (time) => set(({ duration, __controls }) => ({
-              __controls: {
-                ...__controls,
-                requestedRangeToSeekTo: getBoundedSeek(time, duration)
-              },
-              progress: getBoundedSeek(time, duration)
-            })),
-            onDurationChange: (duration) => set(({ live }) => ({
-              duration,
-              live: duration === Number.POSITIVE_INFINITY ? true : live
-            })),
-            setWebsocketMetadata: (metadata) => set(() => ({ __metadata: metadata })),
-            updateBuffered: (buffered) => set(({ duration }) => {
-              const durationFiltered = getFilteredNaN(duration);
-              const percent = durationFiltered > 0 && buffered > 0 ? buffered / durationFiltered * 100 : 0;
-              return {
-                buffered,
-                bufferedPercent: Number(percent.toFixed(2))
-              };
-            }),
-            setVideoQuality: (videoQuality) => set(({ __initialProps, __controls, playbackRate, __device }) => {
-              const parsedSourceNew = getNewSource({
-                accessKey: __initialProps?.accessKey,
-                aspectRatio: __initialProps.aspectRatio,
-                isHlsSupported: __device.isHlsSupported,
-                jwt: __initialProps?.jwt,
-                lowLatency: __initialProps.lowLatency,
-                playbackRate,
-                screenWidth: device.screenWidth,
-                sessionToken: __controls.sessionToken,
-                src,
-                videoQuality,
-                hasRecentWebRTCTimeout: getHasRecentWebRTCTimeout(
-                  __initialProps.cacheWebRTCFailureMs
-                )
-              });
-              return {
-                sortedSources: parsedSourceNew.sortedSources,
-                videoQuality,
-                currentSource: parsedSourceNew.currentSource,
-                __controls: {
-                  ...__controls,
-                  playbackId: playbackId ?? parsedSourceNew.playbackId
-                }
-              };
-            }),
-            setPlaybackRate: (rate) => set(() => ({
-              playbackRate: getBoundedRate(rate ?? 1)
-            })),
-            requestSeekDiff: (difference) => set(({ progress, duration, __controls }) => ({
-              __controls: {
-                ...__controls,
-                requestedRangeToSeekTo: getBoundedSeek(
-                  getFilteredNaN(progress) + difference / 1e3,
-                  duration
-                )
-              }
-            })),
-            requestSeekBack: (difference = DEFAULT_SEEK_TIME) => get().__controlsFunctions.requestSeekDiff(-difference),
-            requestSeekForward: (difference = DEFAULT_SEEK_TIME) => get().__controlsFunctions.requestSeekDiff(difference),
-            onFinalUrl: (currentUrl) => set(() => ({ currentUrl })),
-            requestMeasure: () => set(({ __controls }) => {
-              return {
+            onProgress: (time) =>
+              set(({ aria, progress, duration, live }) => {
+                const progressAria = getProgressAria({
+                  progress,
+                  duration,
+                  live,
+                });
+                const playPauseTitle = "Pause (k)";
+                return {
+                  aria: {
+                    ...aria,
+                    progress: progressAria.progress,
+                    time: progressAria.time,
+                    playPause: playPauseTitle,
+                  },
+                  progress: getFilteredNaN(time),
+                  waiting: false,
+                  stalled: false,
+                  ended: false,
+                };
+              }),
+            requestSeek: (time) =>
+              set(({ duration, __controls }) => ({
                 __controls: {
                   ...__controls,
-                  requestedMeasureLastTime: Date.now()
-                }
-              };
-            }),
-            setSize: (size) => set(({ __controls }) => {
-              return {
+                  requestedRangeToSeekTo: getBoundedSeek(time, duration),
+                },
+                progress: getBoundedSeek(time, duration),
+              })),
+            onDurationChange: (duration) =>
+              set(({ live }) => ({
+                duration,
+                live: duration === Number.POSITIVE_INFINITY ? true : live,
+              })),
+            setWebsocketMetadata: (metadata) =>
+              set(() => ({ __metadata: metadata })),
+            updateBuffered: (buffered) =>
+              set(({ duration }) => {
+                const durationFiltered = getFilteredNaN(duration);
+                const percent =
+                  durationFiltered > 0 && buffered > 0
+                    ? (buffered / durationFiltered) * 100
+                    : 0;
+                return {
+                  buffered,
+                  bufferedPercent: Number(percent.toFixed(2)),
+                };
+              }),
+            setVideoQuality: (videoQuality) =>
+              set(({ __initialProps, __controls, playbackRate, __device }) => {
+                const parsedSourceNew = getNewSource({
+                  accessKey: __initialProps?.accessKey,
+                  aspectRatio: __initialProps.aspectRatio,
+                  isHlsSupported: __device.isHlsSupported,
+                  jwt: __initialProps?.jwt,
+                  lowLatency: __initialProps.lowLatency,
+                  playbackRate,
+                  screenWidth: device.screenWidth,
+                  sessionToken: __controls.sessionToken,
+                  src,
+                  videoQuality,
+                  hasRecentWebRTCTimeout: getHasRecentWebRTCTimeout(
+                    __initialProps.cacheWebRTCFailureMs
+                  ),
+                  forceNoToken: __initialProps?.forceNoToken,
+                });
+                return {
+                  sortedSources: parsedSourceNew.sortedSources,
+                  videoQuality,
+                  currentSource: parsedSourceNew.currentSource,
+                  __controls: {
+                    ...__controls,
+                    playbackId: playbackId ?? parsedSourceNew.playbackId,
+                  },
+                };
+              }),
+            setPlaybackRate: (rate) =>
+              set(() => ({
+                playbackRate: getBoundedRate(rate ?? 1),
+              })),
+            requestSeekDiff: (difference) =>
+              set(({ progress, duration, __controls }) => ({
                 __controls: {
                   ...__controls,
-                  size: {
-                    ...__controls.size,
-                    ...size
-                  }
-                }
-              };
-            }),
+                  requestedRangeToSeekTo: getBoundedSeek(
+                    getFilteredNaN(progress) + difference / 1e3,
+                    duration
+                  ),
+                },
+              })),
+            requestSeekBack: (difference = DEFAULT_SEEK_TIME) =>
+              get().__controlsFunctions.requestSeekDiff(-difference),
+            requestSeekForward: (difference = DEFAULT_SEEK_TIME) =>
+              get().__controlsFunctions.requestSeekDiff(difference),
+            onFinalUrl: (currentUrl) => set(() => ({ currentUrl })),
+            requestMeasure: () =>
+              set(({ __controls }) => {
+                return {
+                  __controls: {
+                    ...__controls,
+                    requestedMeasureLastTime: Date.now(),
+                  },
+                };
+              }),
+            setSize: (size) =>
+              set(({ __controls }) => {
+                return {
+                  __controls: {
+                    ...__controls,
+                    size: {
+                      ...__controls.size,
+                      ...size,
+                    },
+                  },
+                };
+              }),
             onWaiting: () => set(() => ({ waiting: true })),
             onStalled: () => set(() => ({ stalled: true })),
             onLoading: () => set(() => ({ loading: true })),
             onEnded: () => set(() => ({ ended: true })),
-            setFullscreen: (fullscreen) => set(({ aria }) => {
-              const title = fullscreen ? "Exit full screen (f)" : "Full screen (f)";
-              return {
-                fullscreen,
-                aria: {
-                  ...aria,
-                  fullscreen: title
-                }
-              };
-            }),
-            requestToggleFullscreen: () => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                requestedFullscreenLastTime: Date.now()
-              }
-            })),
-            setPictureInPicture: (pictureInPicture) => set(({ aria }) => {
-              const title = pictureInPicture ? "Exit mini player (i)" : "Mini player (i)";
-              return {
-                pictureInPicture,
-                aria: {
-                  ...aria,
-                  pictureInPicture: title
-                }
-              };
-            }),
-            requestTogglePictureInPicture: () => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                requestedPictureInPictureLastTime: Date.now()
-              }
-            })),
+            setFullscreen: (fullscreen) =>
+              set(({ aria }) => {
+                const title = fullscreen
+                  ? "Exit full screen (f)"
+                  : "Full screen (f)";
+                return {
+                  fullscreen,
+                  aria: {
+                    ...aria,
+                    fullscreen: title,
+                  },
+                };
+              }),
+            requestToggleFullscreen: () =>
+              set(({ __controls }) => ({
+                __controls: {
+                  ...__controls,
+                  requestedFullscreenLastTime: Date.now(),
+                },
+              })),
+            setPictureInPicture: (pictureInPicture) =>
+              set(({ aria }) => {
+                const title = pictureInPicture
+                  ? "Exit mini player (i)"
+                  : "Mini player (i)";
+                return {
+                  pictureInPicture,
+                  aria: {
+                    ...aria,
+                    pictureInPicture: title,
+                  },
+                };
+              }),
+            requestTogglePictureInPicture: () =>
+              set(({ __controls }) => ({
+                __controls: {
+                  ...__controls,
+                  requestedPictureInPictureLastTime: Date.now(),
+                },
+              })),
             setLive: (live) => set(() => ({ live })),
-            requestClip: () => set(({ __controls, __initialProps }) => ({
-              __controls: {
-                ...__controls,
-                requestedClipParams: __initialProps.clipLength ? getClipParams({
-                  requestedTime: Date.now(),
-                  clipLength: __initialProps.clipLength,
-                  playbackOffsetMs: __controls.playbackOffsetMs
-                }) : null
-              }
-            })),
-            requestVolume: (newVolume) => set(({ __controls }) => ({
-              volume: getBoundedVolume(newVolume),
-              __controls: {
-                ...__controls,
-                volume: newVolume === 0 ? newVolume : getBoundedVolume(newVolume),
-                muted: newVolume === 0
-              }
-            })),
-            setVolume: (newVolume) => set(({ __controls }) => ({
-              volume: getBoundedVolume(newVolume),
-              __controls: {
-                ...__controls,
-                muted: newVolume === 0
-              }
-            })),
-            requestToggleMute: (forceValue) => set(({ __controls }) => {
-              const previousVolume = getBoundedVolume(__controls.volume) || 0;
-              const nonMutedVolume = previousVolume > 0.01 ? previousVolume : DEFAULT_VOLUME_LEVEL;
-              const mutedVolume = 0;
-              const newMutedValue = forceValue ?? !__controls.muted;
-              return {
-                volume: newMutedValue ? mutedVolume : nonMutedVolume,
+            requestClip: () =>
+              set(({ __controls, __initialProps }) => ({
                 __controls: {
                   ...__controls,
-                  muted: newMutedValue
-                }
-              };
-            }),
-            onError: (rawError) => set(
-              ({
-                currentSource,
-                sortedSources,
-                __controls,
-                errorCount,
-                __device,
-                __initialProps,
-                videoQuality,
-                playbackRate
-              }) => {
-                const msSinceLastError = Date.now() - __controls.lastError;
-                const error = rawError ? {
-                  type: isAccessControlError(rawError) ? "access-control" : isBframesError(rawError) || isNotAcceptableError(rawError) ? "fallback" : isStreamOfflineError(rawError) ? "offline" : isPermissionsError(rawError) ? "permissions" : "unknown",
-                  message: rawError?.message ?? "Error with playback."
-                } : null;
-                if (__initialProps.onError) {
-                  try {
-                    __initialProps.onError(error);
-                  } catch (e) {
-                    console.error(e);
-                  }
-                }
-                const base = {
-                  error,
-                  ...error ? {
-                    errorCount: errorCount + 1,
-                    playing: false,
-                    __controls: {
-                      ...__controls,
-                      lastError: Date.now()
-                    }
-                  } : { __controls }
+                  requestedClipParams: __initialProps.clipLength
+                    ? getClipParams({
+                        requestedTime: Date.now(),
+                        clipLength: __initialProps.clipLength,
+                        playbackOffsetMs: __controls.playbackOffsetMs,
+                      })
+                    : null,
+                },
+              })),
+            requestVolume: (newVolume) =>
+              set(({ __controls }) => ({
+                volume: getBoundedVolume(newVolume),
+                __controls: {
+                  ...__controls,
+                  volume:
+                    newVolume === 0 ? newVolume : getBoundedVolume(newVolume),
+                  muted: newVolume === 0,
+                },
+              })),
+            setVolume: (newVolume) =>
+              set(({ __controls }) => ({
+                volume: getBoundedVolume(newVolume),
+                __controls: {
+                  ...__controls,
+                  muted: newVolume === 0,
+                },
+              })),
+            requestToggleMute: (forceValue) =>
+              set(({ __controls }) => {
+                const previousVolume = getBoundedVolume(__controls.volume) || 0;
+                const nonMutedVolume =
+                  previousVolume > 0.01 ? previousVolume : DEFAULT_VOLUME_LEVEL;
+                const mutedVolume = 0;
+                const newMutedValue = forceValue ?? !__controls.muted;
+                return {
+                  volume: newMutedValue ? mutedVolume : nonMutedVolume,
+                  __controls: {
+                    ...__controls,
+                    muted: newMutedValue,
+                  },
                 };
-                if (!error) {
-                  return base;
-                }
-                console.error(error);
-                if (error.type === "offline" || error.type === "access-control" || error.type === "permissions") {
-                  return base;
-                }
-                if (typeof sortedSources === "string" || !Array.isArray(sortedSources)) {
-                  return base;
-                }
-                if (msSinceLastError < errorCount * 500) {
-                  return base;
-                }
-                const currentSourceBaseUrl = currentSource ? new URL(currentSource.src) : "";
-                if (currentSourceBaseUrl) {
-                  currentSourceBaseUrl.search = "";
-                }
-                const currentSourceIndex = sortedSources.findIndex(
-                  (s) => s.src === currentSourceBaseUrl.toString()
-                );
-                const rotatedSources = [
-                  ...sortedSources.slice(currentSourceIndex + 1),
-                  ...sortedSources.slice(0, currentSourceIndex + 1)
-                ];
-                const hasRecentWebRTCTimeout = getHasRecentWebRTCTimeout(
-                  __initialProps.cacheWebRTCFailureMs
-                );
-                const canPlaySourceType = (src2) => {
-                  const hasOneWebRTCSource = sortedSources.some(
-                    (s) => s?.type === "webrtc"
-                  );
-                  if (__initialProps.lowLatency === "force" && hasOneWebRTCSource && src2.type !== "webrtc") {
-                    return false;
+              }),
+            onError: (rawError) =>
+              set(
+                ({
+                  currentSource,
+                  sortedSources,
+                  __controls,
+                  errorCount,
+                  __device,
+                  __initialProps,
+                  videoQuality,
+                  playbackRate,
+                }) => {
+                  const msSinceLastError = Date.now() - __controls.lastError;
+                  const error = rawError
+                    ? {
+                        type: isAccessControlError(rawError)
+                          ? "access-control"
+                          : isBframesError(rawError) ||
+                            isNotAcceptableError(rawError)
+                          ? "fallback"
+                          : isStreamOfflineError(rawError)
+                          ? "offline"
+                          : isPermissionsError(rawError)
+                          ? "permissions"
+                          : "unknown",
+                        message: rawError?.message ?? "Error with playback.",
+                      }
+                    : null;
+                  if (__initialProps.onError) {
+                    try {
+                      __initialProps.onError(error);
+                    } catch (e) {
+                      console.error(e);
+                    }
                   }
-                  if (__initialProps.lowLatency === false) {
-                    return src2.type !== "webrtc";
+                  const base = {
+                    error,
+                    ...(error
+                      ? {
+                          errorCount: errorCount + 1,
+                          playing: false,
+                          __controls: {
+                            ...__controls,
+                            lastError: Date.now(),
+                          },
+                        }
+                      : { __controls }),
+                  };
+                  if (!error) {
+                    return base;
                   }
-                  if (hasRecentWebRTCTimeout) {
-                    return src2.type !== "webrtc";
+                  console.error(error);
+                  if (
+                    error.type === "offline" ||
+                    error.type === "access-control" ||
+                    error.type === "permissions"
+                  ) {
+                    return base;
                   }
-                  return src2.type === "webrtc" ? __device.isWebRTCSupported : true;
-                };
-                const nextPlayableIndex = rotatedSources.findIndex(
-                  (s) => canPlaySourceType(s)
-                );
-                const nextSourceIndex = nextPlayableIndex !== -1 ? (currentSourceIndex + 1 + nextPlayableIndex) % sortedSources.length : -1;
-                const nextSource = nextSourceIndex !== -1 ? sortedSources[nextSourceIndex] : null;
-                const parsedSourceNew = parseCurrentSourceAndPlaybackId({
-                  accessKey: __initialProps?.accessKey ?? null,
-                  aspectRatio: __initialProps?.aspectRatio ?? null,
-                  isHlsSupported: __device.isHlsSupported,
-                  jwt: __initialProps?.jwt ?? null,
-                  playbackRate,
-                  sessionToken: __controls.sessionToken,
-                  source: nextSource,
-                  videoQuality
-                });
-                return {
-                  ...base,
-                  currentSource: parsedSourceNew?.currentSource ?? null,
-                  __controls: {
-                    ...base.__controls,
-                    playbackId: playbackId ?? parsedSourceNew?.playbackId ?? null
+                  if (
+                    typeof sortedSources === "string" ||
+                    !Array.isArray(sortedSources)
+                  ) {
+                    return base;
                   }
-                };
-              }
-            )
-          }
+                  if (msSinceLastError < errorCount * 500) {
+                    return base;
+                  }
+                  const currentSourceBaseUrl = currentSource
+                    ? new URL(currentSource.src)
+                    : "";
+                  if (currentSourceBaseUrl) {
+                    currentSourceBaseUrl.search = "";
+                  }
+                  const currentSourceIndex = sortedSources.findIndex(
+                    (s) => s.src === currentSourceBaseUrl.toString()
+                  );
+                  const rotatedSources = [
+                    ...sortedSources.slice(currentSourceIndex + 1),
+                    ...sortedSources.slice(0, currentSourceIndex + 1),
+                  ];
+                  const hasRecentWebRTCTimeout = getHasRecentWebRTCTimeout(
+                    __initialProps.cacheWebRTCFailureMs
+                  );
+                  const canPlaySourceType = (src2) => {
+                    const hasOneWebRTCSource = sortedSources.some(
+                      (s) => s?.type === "webrtc"
+                    );
+                    if (
+                      __initialProps.lowLatency === "force" &&
+                      hasOneWebRTCSource &&
+                      src2.type !== "webrtc"
+                    ) {
+                      return false;
+                    }
+                    if (__initialProps.lowLatency === false) {
+                      return src2.type !== "webrtc";
+                    }
+                    if (hasRecentWebRTCTimeout) {
+                      return src2.type !== "webrtc";
+                    }
+                    return src2.type === "webrtc"
+                      ? __device.isWebRTCSupported
+                      : true;
+                  };
+                  const nextPlayableIndex = rotatedSources.findIndex((s) =>
+                    canPlaySourceType(s)
+                  );
+                  const nextSourceIndex =
+                    nextPlayableIndex !== -1
+                      ? (currentSourceIndex + 1 + nextPlayableIndex) %
+                        sortedSources.length
+                      : -1;
+                  const nextSource =
+                    nextSourceIndex !== -1
+                      ? sortedSources[nextSourceIndex]
+                      : null;
+                  const parsedSourceNew = parseCurrentSourceAndPlaybackId({
+                    accessKey: __initialProps?.accessKey ?? null,
+                    aspectRatio: __initialProps?.aspectRatio ?? null,
+                    isHlsSupported: __device.isHlsSupported,
+                    jwt: __initialProps?.jwt ?? null,
+                    playbackRate,
+                    sessionToken: __controls.sessionToken,
+                    source: nextSource,
+                    videoQuality,
+                    forceNoToken: __initialProps?.forceNoToken,
+                  });
+                  return {
+                    ...base,
+                    currentSource: parsedSourceNew?.currentSource ?? null,
+                    __controls: {
+                      ...base.__controls,
+                      playbackId:
+                        playbackId ?? parsedSourceNew?.playbackId ?? null,
+                    },
+                  };
+                }
+              ),
+          },
         }),
         {
           name: "livepeer-media-controller",
@@ -1082,9 +1276,9 @@ var createControllerStore = ({
           // since these values are persisted across media, only persist volume & videoQuality
           partialize: ({ volume, videoQuality }) => ({
             volume,
-            videoQuality
+            videoQuality,
           }),
-          storage: (0, import_middleware.createJSONStorage)(() => storage)
+          storage: (0, import_middleware.createJSONStorage)(() => storage),
         }
       )
     )
@@ -1135,11 +1329,14 @@ var LegacyPlaybackMonitor = class {
   }
   calculateScore() {
     if (this.active) {
-      const latestPlaybackRecord = this.values.length > 0 ? this.values[this.values.length - 1] : void 0;
+      const latestPlaybackRecord =
+        this.values.length > 0 ? this.values[this.values.length - 1] : void 0;
       const currentValue = {
         clockTime: Date.now() * 1e-3,
         mediaTime: this.store.getState().progress,
-        score: latestPlaybackRecord ? this.valueToScore(latestPlaybackRecord) : 0
+        score: latestPlaybackRecord
+          ? this.valueToScore(latestPlaybackRecord)
+          : 0,
       };
       this.values.push(currentValue);
       if (this.values.length < 2) {
@@ -1159,7 +1356,11 @@ var LegacyPlaybackMonitor = class {
   }
   valueToScore(a, b) {
     const rate = this?.store?.getState?.()?.playbackRate ?? 1;
-    return (b?.mediaTime ?? this.store.getState().progress - a.mediaTime) / (b?.clockTime ?? Date.now() * 1e-3 - a.clockTime) / (rate === "constant" ? 1 : rate);
+    return (
+      (b?.mediaTime ?? this.store.getState().progress - a.mediaTime) /
+      (b?.clockTime ?? Date.now() * 1e-3 - a.clockTime) /
+      (rate === "constant" ? 1 : rate)
+    );
   }
 };
 var Timer = class {
@@ -1207,12 +1408,23 @@ var LegacyMetricsStatus = class {
     const currentState = store.getState();
     this.store = store;
     this.bootMs = bootMs;
-    const windowHref = typeof window !== "undefined" ? window?.location?.href ?? "" : "";
-    const pageUrl = isInIframe() ? typeof document !== "undefined" ? document?.referrer || windowHref : windowHref : windowHref;
+    const windowHref =
+      typeof window !== "undefined" ? window?.location?.href ?? "" : "";
+    const pageUrl = isInIframe()
+      ? typeof document !== "undefined"
+        ? document?.referrer || windowHref
+        : windowHref
+      : windowHref;
     const playerPrefix = currentState?.currentSource?.type ?? "unknown";
     const version = currentState?.__device.version ?? "unknown";
     this.currentMetrics = {
-      autoplay: currentState.__initialProps.autoPlay ? "autoplay" : currentState.__initialProps.preload === "auto" ? "preload-full" : currentState.__initialProps.preload === "metadata" ? "preload-metadata" : "standard",
+      autoplay: currentState.__initialProps.autoPlay
+        ? "autoplay"
+        : currentState.__initialProps.preload === "auto"
+        ? "preload-full"
+        : currentState.__initialProps.preload === "metadata"
+        ? "preload-metadata"
+        : "standard",
       duration: null,
       firstPlayback: null,
       nError: null,
@@ -1237,10 +1449,13 @@ var LegacyMetricsStatus = class {
         ""
       ),
       videoHeight: null,
-      videoWidth: null
+      videoWidth: null,
     };
     this.destroy = store.subscribe((state, prevState) => {
-      if (this.requestedPlayTime === null && state.__controls.playLastTime !== 0) {
+      if (
+        this.requestedPlayTime === null &&
+        state.__controls.playLastTime !== 0
+      ) {
         this.requestedPlayTime = Math.max(
           state.__controls.playLastTime - bootMs,
           0
@@ -1264,7 +1479,11 @@ var LegacyMetricsStatus = class {
           this.timeWaiting.stop();
         }
       }
-      if (opts?.disableProgressListener !== true && state.progress !== prevState.progress && !this.timeUnpaused.startTime) {
+      if (
+        opts?.disableProgressListener !== true &&
+        state.progress !== prevState.progress &&
+        !this.timeUnpaused.startTime
+      ) {
         this.timeStalled.stop();
         this.timeWaiting.stop();
         this.timeUnpaused.start();
@@ -1316,8 +1535,10 @@ var LegacyMetricsStatus = class {
   getMetrics() {
     const currentMetrics = {
       ...this.currentMetrics,
-      playerHeight: this.store.getState().__controls.size?.container?.height || null,
-      playerWidth: this.store.getState().__controls.size?.container?.width || null,
+      playerHeight:
+        this.store.getState().__controls.size?.container?.height || null,
+      playerWidth:
+        this.store.getState().__controls.size?.container?.width || null,
       videoWidth: this.store.getState().__controls.size?.media?.width || null,
       videoHeight: this.store.getState().__controls.size?.media?.height || null,
       duration: this.store.getState().duration || null,
@@ -1330,13 +1551,19 @@ var LegacyMetricsStatus = class {
       // this is the amount of time that a video has had to preload content, from boot until play was requested
       preloadTime: this.requestedPlayTime,
       // time from when the first `play` event is emitted and the first progress update
-      ttff: this.firstFrameTime && this.requestedPlayTime && this.firstFrameTime > 0 && this.requestedPlayTime > 0 ? Math.max(this.firstFrameTime - this.requestedPlayTime, 0) : null
+      ttff:
+        this.firstFrameTime &&
+        this.requestedPlayTime &&
+        this.firstFrameTime > 0 &&
+        this.requestedPlayTime > 0
+          ? Math.max(this.firstFrameTime - this.requestedPlayTime, 0)
+          : null,
     };
     const previousMetrics = this.previousMetrics;
     this.previousMetrics = currentMetrics;
     return {
       current: currentMetrics,
-      previous: previousMetrics
+      previous: previousMetrics,
     };
   }
 };
@@ -1344,8 +1571,7 @@ function addLegacyMediaMetricsToStore(store, opts) {
   const bootMs = Date.now();
   const defaultResponse = {
     metrics: null,
-    destroy: () => {
-    }
+    destroy: () => {},
   };
   if (!store) {
     return defaultResponse;
@@ -1373,7 +1599,10 @@ function addLegacyMediaMetricsToStore(store, opts) {
     let key;
     for (key in metrics.current) {
       const val = metrics.current[key];
-      const shouldSendValue = typeof val === "number" ? Number.isFinite(val) && !Number.isNaN(val) && val >= 0 : Boolean(val);
+      const shouldSendValue =
+        typeof val === "number"
+          ? Number.isFinite(val) && !Number.isNaN(val) && val >= 0
+          : Boolean(val);
       if (shouldSendValue && val !== metrics?.previous?.[key]) {
         d[key] = val;
       }
@@ -1388,7 +1617,11 @@ function addLegacyMediaMetricsToStore(store, opts) {
       report();
     }, 1e3);
   };
-  const createNewWebSocket = async (playbackId, currentSource, numRetries = 0) => {
+  const createNewWebSocket = async (
+    playbackId,
+    currentSource,
+    numRetries = 0
+  ) => {
     try {
       if (!playbackId || !currentSource) {
         return null;
@@ -1398,7 +1631,7 @@ function addLegacyMediaMetricsToStore(store, opts) {
       const reportingWebsocketUrl = await getMetricsReportingWebsocketUrl({
         playbackId,
         playbackUrl: currentSource,
-        sessionToken: store.getState().__controls.sessionToken
+        sessionToken: store.getState().__controls.sessionToken,
       });
       if (reportingWebsocketUrl) {
         const newWebSocket = new WebSocket(reportingWebsocketUrl);
@@ -1419,18 +1652,15 @@ function addLegacyMediaMetricsToStore(store, opts) {
           if (timer) {
             clearTimeout(timer);
           }
-          setTimeout(
-            () => {
-              if (reportingActive) {
-                websocketPromise = createNewWebSocket(
-                  playbackId,
-                  currentSource,
-                  numRetries + 1
-                );
-              }
-            },
-            2 ** numRetries * 1e3
-          );
+          setTimeout(() => {
+            if (reportingActive) {
+              websocketPromise = createNewWebSocket(
+                playbackId,
+                currentSource,
+                numRetries + 1
+              );
+            }
+          }, 2 ** numRetries * 1e3);
         });
         return newWebSocket;
       }
@@ -1443,7 +1673,7 @@ function addLegacyMediaMetricsToStore(store, opts) {
     (state) => ({
       playbackId: state.__controls.playbackId,
       finalUrl: state.currentUrl,
-      type: state.currentSource?.type
+      type: state.currentSource?.type,
     }),
     (state) => {
       if (state?.playbackId && state?.finalUrl) {
@@ -1454,26 +1684,41 @@ function addLegacyMediaMetricsToStore(store, opts) {
       fireImmediately: true,
       equalityFn: (a, b) => {
         return a.playbackId === b.playbackId && Boolean(a.finalUrl);
-      }
+      },
     }
   );
   try {
     const destroyTtffListener = store.subscribe((state, prevState) => {
-      if (state.playing !== prevState.playing && metricsStatus.getFirstPlayback() === null) {
+      if (
+        state.playing !== prevState.playing &&
+        metricsStatus.getFirstPlayback() === null
+      ) {
         metricsStatus.setFirstPlayback();
       }
-      if (state.progress !== prevState.progress && metricsStatus.getFirstFrameTime() === null) {
+      if (
+        state.progress !== prevState.progress &&
+        metricsStatus.getFirstFrameTime() === null
+      ) {
         metricsStatus.setFirstFrameTime();
       }
-      if (state.error?.message && state.error?.message !== prevState.error?.message) {
+      if (
+        state.error?.message &&
+        state.error?.message !== prevState.error?.message
+      ) {
         metricsStatus.addError(state.error.message);
       }
     });
     const destroyMonitorListener = store.subscribe((state, prevState) => {
-      if (state.playing !== prevState.playing && state.playing || state.loading !== prevState.loading && state.loading) {
+      if (
+        (state.playing !== prevState.playing && state.playing) ||
+        (state.loading !== prevState.loading && state.loading)
+      ) {
         monitor.init();
       }
-      if (state.__controls.requestedRangeToSeekTo !== prevState.__controls.requestedRangeToSeekTo) {
+      if (
+        state.__controls.requestedRangeToSeekTo !==
+        prevState.__controls.requestedRangeToSeekTo
+      ) {
         monitor.reset();
       }
       if (state.playing !== prevState.playing && !state.playing) {
@@ -1520,34 +1765,37 @@ var isObject = (obj) => {
   }
   return false;
 };
-var merge = (...objects) => objects.reduce((result, current) => {
-  if (Array.isArray(current)) {
-    throw new TypeError(
-      "Arguments provided to ts-deepmerge must be objects, not arrays."
-    );
-  }
-  Object.keys(current).forEach((key) => {
-    if (["__proto__", "constructor", "prototype"].includes(key)) {
-      return;
-    }
-    if (Array.isArray(result[key]) && Array.isArray(current[key])) {
-      result[key] = merge.options.mergeArrays ? Array.from(new Set(result[key].concat(current[key]))) : current[key];
-    } else if (isObject(result[key]) && isObject(current[key])) {
-      result[key] = merge(result[key], current[key]);
-    } else {
-      result[key] = current[key];
+var merge = (...objects) =>
+  objects.reduce((result, current) => {
+    if (Array.isArray(current)) {
+      throw new TypeError(
+        "Arguments provided to ts-deepmerge must be objects, not arrays."
+      );
     }
-  });
-  return result;
-}, {});
+    Object.keys(current).forEach((key) => {
+      if (["__proto__", "constructor", "prototype"].includes(key)) {
+        return;
+      }
+      if (Array.isArray(result[key]) && Array.isArray(current[key])) {
+        result[key] = merge.options.mergeArrays
+          ? Array.from(new Set(result[key].concat(current[key])))
+          : current[key];
+      } else if (isObject(result[key]) && isObject(current[key])) {
+        result[key] = merge(result[key], current[key]);
+      } else {
+        result[key] = current[key];
+      }
+    });
+    return result;
+  }, {});
 var defaultOptions = {
-  mergeArrays: true
+  mergeArrays: true,
 };
 merge.options = defaultOptions;
 merge.withOptions = (options, ...objects) => {
   merge.options = {
     mergeArrays: true,
-    ...options
+    ...options,
   };
   const result = merge(...objects);
   merge.options = defaultOptions;
@@ -1570,8 +1818,7 @@ function warn(message, id) {
 var globalLoadTimestampMs = Date.now();
 function addMetricsToStore(store, opts) {
   const defaultResponse = {
-    destroy: () => {
-    }
+    destroy: () => {},
   };
   if (!store) {
     return defaultResponse;
@@ -1580,19 +1827,19 @@ function addMetricsToStore(store, opts) {
     return defaultResponse;
   }
   const monitor = new MetricsMonitor(store, {
-    disableProgressListener: opts?.disableProgressListener
+    disableProgressListener: opts?.disableProgressListener,
   });
   const isSendBeaconAvailable = "sendBeacon" in window.navigator;
   const interval = opts?.interval ?? 5e3;
   const eventBuffer = new PlaybackEventBuffer();
   const destroyFinalUrlListener = store.subscribe(
     (state) => ({
-      finalUrl: state.currentUrl
+      finalUrl: state.currentUrl,
     }),
     async (state) => {
       if (state?.finalUrl) {
         const url = await getMetricsReportingPOSTUrl({
-          playbackUrl: state.finalUrl
+          playbackUrl: state.finalUrl,
         });
         if (url) {
           store.getState().__controlsFunctions.setMetricsReportingUrl(url);
@@ -1603,7 +1850,7 @@ function addMetricsToStore(store, opts) {
       fireImmediately: true,
       equalityFn: (a, b) => {
         return a.finalUrl === b.finalUrl;
-      }
+      },
     }
   );
   const destroyErrorListener = store.subscribe(
@@ -1611,19 +1858,21 @@ function addMetricsToStore(store, opts) {
     async (error) => {
       if (error) {
         eventBuffer.addEvent(
-          error.type === "offline" || error.type === "fallback" ? {
-            id: generateRandomToken(),
-            type: "warning",
-            timestamp: Date.now(),
-            category: error.type,
-            message: error.message
-          } : {
-            id: generateRandomToken(),
-            type: "error",
-            timestamp: Date.now(),
-            category: error.type,
-            message: error.message
-          }
+          error.type === "offline" || error.type === "fallback"
+            ? {
+                id: generateRandomToken(),
+                type: "warning",
+                timestamp: Date.now(),
+                category: error.type,
+                message: error.message,
+              }
+            : {
+                id: generateRandomToken(),
+                type: "error",
+                timestamp: Date.now(),
+                category: error.type,
+                message: error.message,
+              }
         );
       }
     }
@@ -1634,7 +1883,7 @@ function addMetricsToStore(store, opts) {
       eventBuffer.addEvent({
         id: generateRandomToken(),
         type: "play",
-        timestamp
+        timestamp,
       });
     }
   );
@@ -1644,7 +1893,7 @@ function addMetricsToStore(store, opts) {
       eventBuffer.addEvent({
         id: generateRandomToken(),
         type: "pause",
-        timestamp
+        timestamp,
       });
     }
   );
@@ -1657,7 +1906,7 @@ function addMetricsToStore(store, opts) {
           type: "clip",
           timestamp: Date.now(),
           startTime: params.startTime,
-          endTime: params.endTime
+          endTime: params.endTime,
         });
       }
     }
@@ -1668,7 +1917,7 @@ function addMetricsToStore(store, opts) {
       eventBuffer.addEvent({
         id: generateRandomToken(),
         type: pictureInPicture ? "enter-pip" : "exit-pip",
-        timestamp: Date.now()
+        timestamp: Date.now(),
       });
     }
   );
@@ -1678,7 +1927,7 @@ function addMetricsToStore(store, opts) {
       eventBuffer.addEvent({
         id: generateRandomToken(),
         type: fullscreen ? "enter-fullscreen" : "exit-fullscreen",
-        timestamp: Date.now()
+        timestamp: Date.now(),
       });
     }
   );
@@ -1689,7 +1938,7 @@ function addMetricsToStore(store, opts) {
         eventBuffer.addEvent({
           id: generateRandomToken(),
           type: "can-play",
-          timestamp: Date.now()
+          timestamp: Date.now(),
         });
       }
     }
@@ -1701,7 +1950,7 @@ function addMetricsToStore(store, opts) {
         eventBuffer.addEvent({
           id: generateRandomToken(),
           type: "ended",
-          timestamp: Date.now()
+          timestamp: Date.now(),
         });
       }
     }
@@ -1713,7 +1962,7 @@ function addMetricsToStore(store, opts) {
         id: generateRandomToken(),
         type: "rate",
         timestamp: Date.now(),
-        payload: playbackRate
+        payload: playbackRate,
       });
     }
   );
@@ -1724,7 +1973,7 @@ function addMetricsToStore(store, opts) {
         id: generateRandomToken(),
         type: "video-quality",
         timestamp: Date.now(),
-        payload: videoQuality
+        payload: videoQuality,
       });
     }
   );
@@ -1735,7 +1984,7 @@ function addMetricsToStore(store, opts) {
         id: generateRandomToken(),
         type: "seek",
         timestamp: Date.now(),
-        payload: rangeToSeekTo
+        payload: rangeToSeekTo,
       });
     }
   );
@@ -1748,7 +1997,7 @@ function addMetricsToStore(store, opts) {
     "time_errored_ms",
     "time_stalled_ms",
     "time_playing_ms",
-    "time_waiting_ms"
+    "time_waiting_ms",
   ]);
   const vct = new ValueChangeTracker([
     "autoplay_status",
@@ -1762,191 +2011,203 @@ function addMetricsToStore(store, opts) {
     "player_width_px",
     "player_height_px",
     "window_height_px",
-    "window_width_px"
+    "window_width_px",
   ]);
   let firstFrameSent = false;
-  const sendEvents = ({ isUnloading } = { isUnloading: false }) => async () => {
-    const currentState = store.getState();
-    const currentControlsState = currentState.__controls;
-    if (!currentState.currentSource) {
-      warn("Not sending metrics since no current playback source parsed.");
-      return;
-    }
-    if (!currentControlsState.playbackId) {
-      warn("Not sending metrics since no playback ID parsed.");
-      return;
-    }
-    const metricsSnapshot = monitor.getMetrics();
-    if (!firstFrameSent && monitor.firstFrameTimestamp) {
+  const sendEvents =
+    ({ isUnloading } = { isUnloading: false }) =>
+    async () => {
+      const currentState = store.getState();
+      const currentControlsState = currentState.__controls;
+      if (!currentState.currentSource) {
+        warn("Not sending metrics since no current playback source parsed.");
+        return;
+      }
+      if (!currentControlsState.playbackId) {
+        warn("Not sending metrics since no playback ID parsed.");
+        return;
+      }
+      const metricsSnapshot = monitor.getMetrics();
+      if (!firstFrameSent && monitor.firstFrameTimestamp) {
+        eventBuffer.addEvent({
+          id: generateRandomToken(),
+          type: "first-frame",
+          timestamp: monitor.firstFrameTimestamp,
+        });
+        firstFrameSent = true;
+      }
       eventBuffer.addEvent({
         id: generateRandomToken(),
-        type: "first-frame",
-        timestamp: monitor.firstFrameTimestamp
+        type: "heartbeat",
+        timestamp: Date.now(),
+        errors: ic.calculateIncrement("errors", metricsSnapshot.errorCount),
+        warnings: ic.calculateIncrement(
+          "warnings",
+          metricsSnapshot.warningCount
+        ),
+        stalled_count: ic.calculateIncrement(
+          "stalled_count",
+          metricsSnapshot.stalledCount
+        ),
+        waiting_count: ic.calculateIncrement(
+          "waiting_count",
+          metricsSnapshot.waitingCount
+        ),
+        time_errored_ms: ic.calculateIncrement(
+          "time_errored_ms",
+          metricsSnapshot.timeErrored
+        ),
+        time_warning_ms: ic.calculateIncrement(
+          "time_warning_ms",
+          metricsSnapshot.timeWarning
+        ),
+        time_stalled_ms: ic.calculateIncrement(
+          "time_stalled_ms",
+          metricsSnapshot.timeStalled
+        ),
+        time_playing_ms: ic.calculateIncrement(
+          "time_playing_ms",
+          metricsSnapshot.timePlaying
+        ),
+        time_waiting_ms: ic.calculateIncrement(
+          "time_waiting_ms",
+          metricsSnapshot.timeWaiting
+        ),
+        // The properties below are only sent once.
+        autoplay_status: vct.sendIfChanged(
+          "autoplay_status",
+          currentState.__initialProps.autoPlay ? "autoplay" : "none"
+        ),
+        mount_to_play_ms: vct.sendIfChanged(
+          "mount_to_play_ms",
+          metricsSnapshot.mountToPlay ?? void 0
+        ),
+        mount_to_first_frame_ms: vct.sendIfChanged(
+          "mount_to_first_frame_ms",
+          metricsSnapshot.mountToFirstFrame ?? void 0
+        ),
+        play_to_first_frame_ms: vct.sendIfChanged(
+          "play_to_first_frame_ms",
+          metricsSnapshot.playToFirstFrame ?? void 0
+        ),
+        duration_ms: currentState?.live
+          ? void 0
+          : vct.sendIfChanged(
+              "duration_ms",
+              metricsSnapshot.duration ?? void 0
+            ),
+        offset_ms: vct.sendIfChanged(
+          "offset_ms",
+          metricsSnapshot.offset ?? void 0
+        ),
+        // The properties below are only sent when they change.
+        video_height_px: vct.sendIfChanged(
+          "video_height_px",
+          metricsSnapshot.videoHeight ?? void 0
+        ),
+        video_width_px: vct.sendIfChanged(
+          "video_width_px",
+          metricsSnapshot.videoWidth ?? void 0
+        ),
+        player_height_px: vct.sendIfChanged(
+          "player_height_px",
+          metricsSnapshot.playerHeight ?? void 0
+        ),
+        player_width_px: vct.sendIfChanged(
+          "player_width_px",
+          metricsSnapshot.playerWidth ?? void 0
+        ),
+        window_height_px: vct.sendIfChanged(
+          "window_height_px",
+          metricsSnapshot.windowHeight ?? void 0
+        ),
+        window_width_px: vct.sendIfChanged(
+          "window_width_px",
+          metricsSnapshot.windowWidth ?? void 0
+        ),
       });
-      firstFrameSent = true;
-    }
-    eventBuffer.addEvent({
-      id: generateRandomToken(),
-      type: "heartbeat",
-      timestamp: Date.now(),
-      errors: ic.calculateIncrement("errors", metricsSnapshot.errorCount),
-      warnings: ic.calculateIncrement(
-        "warnings",
-        metricsSnapshot.warningCount
-      ),
-      stalled_count: ic.calculateIncrement(
-        "stalled_count",
-        metricsSnapshot.stalledCount
-      ),
-      waiting_count: ic.calculateIncrement(
-        "waiting_count",
-        metricsSnapshot.waitingCount
-      ),
-      time_errored_ms: ic.calculateIncrement(
-        "time_errored_ms",
-        metricsSnapshot.timeErrored
-      ),
-      time_warning_ms: ic.calculateIncrement(
-        "time_warning_ms",
-        metricsSnapshot.timeWarning
-      ),
-      time_stalled_ms: ic.calculateIncrement(
-        "time_stalled_ms",
-        metricsSnapshot.timeStalled
-      ),
-      time_playing_ms: ic.calculateIncrement(
-        "time_playing_ms",
-        metricsSnapshot.timePlaying
-      ),
-      time_waiting_ms: ic.calculateIncrement(
-        "time_waiting_ms",
-        metricsSnapshot.timeWaiting
-      ),
-      // The properties below are only sent once.
-      autoplay_status: vct.sendIfChanged(
-        "autoplay_status",
-        currentState.__initialProps.autoPlay ? "autoplay" : "none"
-      ),
-      mount_to_play_ms: vct.sendIfChanged(
-        "mount_to_play_ms",
-        metricsSnapshot.mountToPlay ?? void 0
-      ),
-      mount_to_first_frame_ms: vct.sendIfChanged(
-        "mount_to_first_frame_ms",
-        metricsSnapshot.mountToFirstFrame ?? void 0
-      ),
-      play_to_first_frame_ms: vct.sendIfChanged(
-        "play_to_first_frame_ms",
-        metricsSnapshot.playToFirstFrame ?? void 0
-      ),
-      duration_ms: currentState?.live ? void 0 : vct.sendIfChanged(
-        "duration_ms",
-        metricsSnapshot.duration ?? void 0
-      ),
-      offset_ms: vct.sendIfChanged(
-        "offset_ms",
-        metricsSnapshot.offset ?? void 0
-      ),
-      // The properties below are only sent when they change.
-      video_height_px: vct.sendIfChanged(
-        "video_height_px",
-        metricsSnapshot.videoHeight ?? void 0
-      ),
-      video_width_px: vct.sendIfChanged(
-        "video_width_px",
-        metricsSnapshot.videoWidth ?? void 0
-      ),
-      player_height_px: vct.sendIfChanged(
-        "player_height_px",
-        metricsSnapshot.playerHeight ?? void 0
-      ),
-      player_width_px: vct.sendIfChanged(
-        "player_width_px",
-        metricsSnapshot.playerWidth ?? void 0
-      ),
-      window_height_px: vct.sendIfChanged(
-        "window_height_px",
-        metricsSnapshot.windowHeight ?? void 0
-      ),
-      window_width_px: vct.sendIfChanged(
-        "window_width_px",
-        metricsSnapshot.windowWidth ?? void 0
-      )
-    });
-    const internalEvents = eventBuffer.getInternalEvents();
-    try {
-      await opts?.onPlaybackEvents?.(internalEvents);
-    } catch (e) {
-      console.error(e);
-      eventBuffer.onInternalFailure(internalEvents);
-    }
-    const metricsUrl = currentState.metricsReportingUrl;
-    if (metricsUrl) {
-      const abortController = new AbortController();
-      const id = setTimeout(
-        () => abortController.abort(),
-        interval - 500
-        // we abort 500ms before the next request is scheduled
-      );
-      const externalEvents = eventBuffer.getExternalEvents();
-      if (isUnloading && externalEvents.length === 0) {
-        return;
-      }
+      const internalEvents = eventBuffer.getInternalEvents();
       try {
-        const windowHref = typeof window !== "undefined" ? window?.location?.href ?? null : null;
-        const pageUrlString = isInIframe2() ? typeof document !== "undefined" ? document?.referrer || windowHref : windowHref : windowHref;
-        const pageUrl = pageUrlString ? new URL(pageUrlString) : null;
-        const playerPrefix = currentState?.currentSource?.type ?? "unknown";
-        const version = currentState?.__device.version ?? "unknown";
-        const sessionData = {
-          live: currentState.live,
-          session_id: currentControlsState.sessionToken,
-          playback_id: currentControlsState.playbackId,
-          protocol: currentState.currentSource.mime ?? void 0,
-          domain: pageUrl?.hostname ?? null,
-          path: pageUrl?.pathname ?? null,
-          params: pageUrl?.search ?? null,
-          hash: pageUrl?.hash ?? null,
-          source_url: currentState.currentSource.src,
-          player: playerPrefix,
-          version,
-          user_agent: String(currentState?.__device?.userAgent ?? "").replace(
-            /\\|"/gm,
-            ""
-          ),
-          uid: currentState.__initialProps.viewerId ?? void 0,
-          events: externalEvents
-        };
-        const data = JSON.stringify(sessionData);
-        if (isUnloading && isSendBeaconAvailable) {
-          const success = window?.navigator?.sendBeacon?.(metricsUrl, data);
-          if (!success) {
-            throw new Error("Beacon response was not OK");
-          }
-        } else {
-          const response = await fetch(metricsUrl, {
-            method: "POST",
-            mode: "cors",
-            body: data,
-            signal: abortController.signal
-          });
-          await response.text();
-          if (!response.ok) {
-            throw new Error("Fetch response was not OK");
-          }
-        }
+        await opts?.onPlaybackEvents?.(internalEvents);
       } catch (e) {
-        console.error(
-          new Error(
-            e?.message ?? "Error with metrics reporting, re-enqueuing events..."
-          )
+        console.error(e);
+        eventBuffer.onInternalFailure(internalEvents);
+      }
+      const metricsUrl = currentState.metricsReportingUrl;
+      if (metricsUrl) {
+        const abortController = new AbortController();
+        const id = setTimeout(
+          () => abortController.abort(),
+          interval - 500
+          // we abort 500ms before the next request is scheduled
         );
-        eventBuffer.onExternalFailure(externalEvents);
-      } finally {
-        clearTimeout(id);
+        const externalEvents = eventBuffer.getExternalEvents();
+        if (isUnloading && externalEvents.length === 0) {
+          return;
+        }
+        try {
+          const windowHref =
+            typeof window !== "undefined"
+              ? window?.location?.href ?? null
+              : null;
+          const pageUrlString = isInIframe2()
+            ? typeof document !== "undefined"
+              ? document?.referrer || windowHref
+              : windowHref
+            : windowHref;
+          const pageUrl = pageUrlString ? new URL(pageUrlString) : null;
+          const playerPrefix = currentState?.currentSource?.type ?? "unknown";
+          const version = currentState?.__device.version ?? "unknown";
+          const sessionData = {
+            live: currentState.live,
+            session_id: currentControlsState.sessionToken,
+            playback_id: currentControlsState.playbackId,
+            protocol: currentState.currentSource.mime ?? void 0,
+            domain: pageUrl?.hostname ?? null,
+            path: pageUrl?.pathname ?? null,
+            params: pageUrl?.search ?? null,
+            hash: pageUrl?.hash ?? null,
+            source_url: currentState.currentSource.src,
+            player: playerPrefix,
+            version,
+            user_agent: String(currentState?.__device?.userAgent ?? "").replace(
+              /\\|"/gm,
+              ""
+            ),
+            uid: currentState.__initialProps.viewerId ?? void 0,
+            events: externalEvents,
+          };
+          const data = JSON.stringify(sessionData);
+          if (isUnloading && isSendBeaconAvailable) {
+            const success = window?.navigator?.sendBeacon?.(metricsUrl, data);
+            if (!success) {
+              throw new Error("Beacon response was not OK");
+            }
+          } else {
+            const response = await fetch(metricsUrl, {
+              method: "POST",
+              mode: "cors",
+              body: data,
+              signal: abortController.signal,
+            });
+            await response.text();
+            if (!response.ok) {
+              throw new Error("Fetch response was not OK");
+            }
+          }
+        } catch (e) {
+          console.error(
+            new Error(
+              e?.message ??
+                "Error with metrics reporting, re-enqueuing events..."
+            )
+          );
+          eventBuffer.onExternalFailure(externalEvents);
+        } finally {
+          clearTimeout(id);
+        }
       }
-    }
-  };
+    };
   const eventsTimer = setInterval(sendEvents(), interval);
   const unloadEvent = "onpagehide" in self ? "pagehide" : "unload";
   const unloadingCallback = sendEvents({ isUnloading: true });
@@ -1975,7 +2236,7 @@ function addMetricsToStore(store, opts) {
       destroySeekListener?.();
       destroyVideoQualityListener?.();
       window?.removeEventListener?.("visibilitychange", onVisibilityChange);
-    }
+    },
   };
 }
 function isInIframe2() {
@@ -2022,20 +2283,39 @@ var PlaybackEventBuffer = class {
           warnings: existingEvent.warnings + newEvent.warnings,
           stalled_count: existingEvent.stalled_count + newEvent.stalled_count,
           waiting_count: existingEvent.waiting_count + newEvent.waiting_count,
-          time_warning_ms: existingEvent.time_warning_ms + newEvent.time_warning_ms,
-          time_errored_ms: existingEvent.time_errored_ms + newEvent.time_errored_ms,
-          time_stalled_ms: existingEvent.time_stalled_ms + newEvent.time_stalled_ms,
-          time_playing_ms: existingEvent.time_playing_ms + newEvent.time_playing_ms,
-          time_waiting_ms: existingEvent.time_waiting_ms + newEvent.time_waiting_ms,
-          ...existingEvent.mount_to_first_frame_ms || newEvent.mount_to_first_frame_ms ? {
-            mount_to_first_frame_ms: (existingEvent.mount_to_first_frame_ms ?? 0) + (newEvent.mount_to_first_frame_ms ?? 0)
-          } : {},
-          ...existingEvent.mount_to_play_ms || newEvent.mount_to_play_ms ? {
-            mount_to_play_ms: (existingEvent.mount_to_play_ms ?? 0) + (newEvent.mount_to_play_ms ?? 0)
-          } : {},
-          ...existingEvent.play_to_first_frame_ms || newEvent.play_to_first_frame_ms ? {
-            play_to_first_frame_ms: (existingEvent.play_to_first_frame_ms ?? 0) + (newEvent.play_to_first_frame_ms ?? 0)
-          } : {}
+          time_warning_ms:
+            existingEvent.time_warning_ms + newEvent.time_warning_ms,
+          time_errored_ms:
+            existingEvent.time_errored_ms + newEvent.time_errored_ms,
+          time_stalled_ms:
+            existingEvent.time_stalled_ms + newEvent.time_stalled_ms,
+          time_playing_ms:
+            existingEvent.time_playing_ms + newEvent.time_playing_ms,
+          time_waiting_ms:
+            existingEvent.time_waiting_ms + newEvent.time_waiting_ms,
+          ...(existingEvent.mount_to_first_frame_ms ||
+          newEvent.mount_to_first_frame_ms
+            ? {
+                mount_to_first_frame_ms:
+                  (existingEvent.mount_to_first_frame_ms ?? 0) +
+                  (newEvent.mount_to_first_frame_ms ?? 0),
+              }
+            : {}),
+          ...(existingEvent.mount_to_play_ms || newEvent.mount_to_play_ms
+            ? {
+                mount_to_play_ms:
+                  (existingEvent.mount_to_play_ms ?? 0) +
+                  (newEvent.mount_to_play_ms ?? 0),
+              }
+            : {}),
+          ...(existingEvent.play_to_first_frame_ms ||
+          newEvent.play_to_first_frame_ms
+            ? {
+                play_to_first_frame_ms:
+                  (existingEvent.play_to_first_frame_ms ?? 0) +
+                  (newEvent.play_to_first_frame_ms ?? 0),
+              }
+            : {}),
         };
         this.externalBuffer[existingEventIndex] = mergedEvent;
       }
@@ -2075,13 +2355,10 @@ var PlaybackEventBuffer = class {
 var IncrementalCounter = class {
   counts;
   constructor(keys) {
-    this.counts = keys.reduce(
-      (acc, key) => {
-        acc[key] = 0;
-        return acc;
-      },
-      {}
-    );
+    this.counts = keys.reduce((acc, key) => {
+      acc[key] = 0;
+      return acc;
+    }, {});
   }
   calculateIncrement(key, newCount) {
     if (newCount < this.counts[key]) {
@@ -2095,13 +2372,10 @@ var IncrementalCounter = class {
 var ValueChangeTracker = class {
   lastValues;
   constructor(keys) {
-    this.lastValues = keys.reduce(
-      (acc, key) => {
-        acc[key] = void 0;
-        return acc;
-      },
-      {}
-    );
+    this.lastValues = keys.reduce((acc, key) => {
+      acc[key] = void 0;
+      return acc;
+    }, {});
   }
   sendIfChanged(key, newValue) {
     if (this.lastValues[key] !== newValue) {
@@ -2167,7 +2441,7 @@ var MetricsMonitor = class {
       videoWidth: null,
       waitingCount: 0,
       windowHeight: null,
-      windowWidth: null
+      windowWidth: null,
     };
     const destroyFirstPlayListener = store.subscribe(
       (state) => state.__controls.playLastTime,
@@ -2211,7 +2485,10 @@ var MetricsMonitor = class {
     const destroyProgressListener = store.subscribe(
       (state) => state.progress,
       async () => {
-        if (opts.disableProgressListener !== true && !this.timerPlaying.startTime) {
+        if (
+          opts.disableProgressListener !== true &&
+          !this.timerPlaying.startTime
+        ) {
           this.timerWarning.stop();
           this.timerErrored.stop();
           this.timerStalled.stop();
@@ -2225,7 +2502,10 @@ var MetricsMonitor = class {
             0
           );
         }
-        if (this.currentMetrics.playToFirstFrame === null && this.currentMetrics.mountToPlay !== null) {
+        if (
+          this.currentMetrics.playToFirstFrame === null &&
+          this.currentMetrics.mountToPlay !== null
+        ) {
           this.currentMetrics.playToFirstFrame = Math.max(
             now - this.currentMetrics.mountToPlay - globalLoadTimestampMs,
             0
@@ -2238,7 +2518,8 @@ var MetricsMonitor = class {
       (state) => state.error,
       async (error) => {
         if (error?.type) {
-          const isWarning = error.type === "offline" || error.type === "fallback";
+          const isWarning =
+            error.type === "offline" || error.type === "fallback";
           if (isWarning) {
             this.timerWarning.start();
           } else {
@@ -2294,13 +2575,19 @@ var MetricsMonitor = class {
     const duration = this.store.getState().duration;
     const currentMetrics = {
       ...this.currentMetrics,
-      playerHeight: this.store.getState().__controls.size?.container?.height || null,
-      playerWidth: this.store.getState().__controls.size?.container?.width || null,
+      playerHeight:
+        this.store.getState().__controls.size?.container?.height || null,
+      playerWidth:
+        this.store.getState().__controls.size?.container?.width || null,
       videoWidth: this.store.getState().__controls.size?.media?.width || null,
       videoHeight: this.store.getState().__controls.size?.media?.height || null,
       windowWidth: this.store.getState().__controls.size?.window?.width || null,
-      windowHeight: this.store.getState().__controls.size?.window?.height || null,
-      duration: Number.isFinite(duration) && !Number.isNaN(duration) ? Math.floor(duration * 1e3) : null,
+      windowHeight:
+        this.store.getState().__controls.size?.window?.height || null,
+      duration:
+        Number.isFinite(duration) && !Number.isNaN(duration)
+          ? Math.floor(duration * 1e3)
+          : null,
       waitingCount: this.timerWaiting.getCountStarts(),
       stalledCount: this.timerStalled.getCountStarts(),
       timeWarning: this.timerWarning.getTotalTime(),
@@ -2308,18 +2595,19 @@ var MetricsMonitor = class {
       timeWaiting: this.timerWaiting.getTotalTime(),
       timeStalled: this.timerStalled.getTotalTime(),
       timePlaying: this.timerPlaying.getTotalTime(),
-      offset: this.store.getState().__controls.playbackOffsetMs ?? null
+      offset: this.store.getState().__controls.playbackOffsetMs ?? null,
     };
     return currentMetrics;
   }
 };
 // Annotate the CommonJS export names for ESM import in node:
-0 && (module.exports = {
-  addLegacyMediaMetricsToStore,
-  addMetricsToStore,
-  calculateVideoQualityDimensions,
-  createControllerStore,
-  getBoundedVolume,
-  getMediaSourceType
-});
+0 &&
+  (module.exports = {
+    addLegacyMediaMetricsToStore,
+    addMetricsToStore,
+    calculateVideoQualityDimensions,
+    createControllerStore,
+    getBoundedVolume,
+    getMediaSourceType,
+  });
 //# sourceMappingURL=index.cjs.map
\ No newline at end of file
diff --git a/dist/media/index.d.cts b/dist/media/index.d.cts
index 1c17bb63a984648666e2e70e80ae8901dc06266e..3f86a99235495e112e666a4881222ee9141205a0 100644
--- a/dist/media/index.d.cts
+++ b/dist/media/index.d.cts
@@ -1,491 +1,529 @@
-import { StoreApi } from 'zustand/vanilla';
+import { StoreApi } from "zustand/vanilla";
 
 type MimeType = keyof typeof mime;
 declare const mime: {
-    readonly "application/mp4": readonly ["mp4s", "m4p"];
-    readonly "application/ogg": readonly ["ogx"];
-    readonly "application/vnd.apple.mpegurl": readonly ["m3u8"];
-    readonly "audio/3gpp": readonly ["*3gpp"];
-    readonly "audio/adpcm": readonly ["adp"];
-    readonly "audio/amr": readonly ["amr"];
-    readonly "audio/basic": readonly ["au", "snd"];
-    readonly "audio/midi": readonly ["mid", "midi", "kar", "rmi"];
-    readonly "audio/mobile-xmf": readonly ["mxmf"];
-    readonly "audio/mp3": readonly ["*mp3"];
-    readonly "audio/mp4": readonly ["m4a", "mp4a"];
-    readonly "audio/mpeg": readonly ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"];
-    readonly "audio/ogg": readonly ["oga", "ogg", "spx", "opus"];
-    readonly "audio/s3m": readonly ["s3m"];
-    readonly "audio/silk": readonly ["sil"];
-    readonly "audio/vnd.dece.audio": readonly ["uva", "uvva"];
-    readonly "audio/vnd.digital-winds": readonly ["eol"];
-    readonly "audio/vnd.dra": readonly ["dra"];
-    readonly "audio/vnd.dts.hd": readonly ["dtshd"];
-    readonly "audio/vnd.dts": readonly ["dts"];
-    readonly "audio/vnd.lucent.voice": readonly ["lvp"];
-    readonly "audio/vnd.ms-playready.media.pya": readonly ["pya"];
-    readonly "audio/vnd.nuera.ecelp4800": readonly ["ecelp4800"];
-    readonly "audio/vnd.nuera.ecelp7470": readonly ["ecelp7470"];
-    readonly "audio/vnd.nuera.ecelp9600": readonly ["ecelp9600"];
-    readonly "audio/vnd.rip": readonly ["rip"];
-    readonly "audio/wav": readonly ["wav"];
-    readonly "audio/wave": readonly ["*wav"];
-    readonly "audio/webm": readonly ["weba"];
-    readonly "audio/x-aac": readonly ["aac"];
-    readonly "audio/x-aiff": readonly ["aif", "aiff", "aifc"];
-    readonly "audio/x-caf": readonly ["caf"];
-    readonly "audio/x-flac": readonly ["flac"];
-    readonly "audio/x-m4a": readonly ["*m4a"];
-    readonly "audio/x-matroska": readonly ["mka"];
-    readonly "audio/x-mpegurl": readonly ["m3u"];
-    readonly "audio/x-ms-wax": readonly ["wax"];
-    readonly "audio/x-ms-wma": readonly ["wma"];
-    readonly "audio/x-pn-realaudio-plugin": readonly ["rmp"];
-    readonly "audio/x-pn-realaudio": readonly ["ram", "ra"];
-    readonly "audio/x-realaudio": readonly ["*ra"];
-    readonly "audio/x-wav": readonly ["*wav"];
-    readonly "audio/xm": readonly ["xm"];
-    readonly "video/3gpp": readonly ["3gp", "3gpp"];
-    readonly "video/3gpp2": readonly ["3g2"];
-    readonly "video/h261": readonly ["h261"];
-    readonly "video/h263": readonly ["h263"];
-    readonly "video/h264": readonly ["h264"];
-    readonly "video/iso.segment": readonly ["m4s"];
-    readonly "video/jpeg": readonly ["jpgv"];
-    readonly "video/jpm": readonly ["*jpm", "jpgm"];
-    readonly "video/mj2": readonly ["mj2", "mjp2"];
-    readonly "video/mp2t": readonly ["ts"];
-    readonly "video/mp4": readonly ["mp4", "mp4v", "mpg4"];
-    readonly "video/mpeg": readonly ["mpeg", "mpg", "mpe", "m1v", "m2v"];
-    readonly "video/ogg": readonly ["ogv"];
-    readonly "video/quicktime": readonly ["qt", "mov"];
-    readonly "video/vnd.dece.hd": readonly ["uvh", "uvvh"];
-    readonly "video/vnd.dece.mobile": readonly ["uvm", "uvvm"];
-    readonly "video/vnd.dece.pd": readonly ["uvp", "uvvp"];
-    readonly "video/vnd.dece.sd": readonly ["uvs", "uvvs"];
-    readonly "video/vnd.dece.video": readonly ["uvv", "uvvv"];
-    readonly "video/vnd.dvb.file": readonly ["dvb"];
-    readonly "video/vnd.fvt": readonly ["fvt"];
-    readonly "video/vnd.mpegurl": readonly ["mxu", "m4u"];
-    readonly "video/vnd.ms-playready.media.pyv": readonly ["pyv"];
-    readonly "video/vnd.uvvu.mp4": readonly ["uvu", "uvvu"];
-    readonly "video/vnd.vivo": readonly ["viv"];
-    readonly "video/vp8": readonly ["vp8"];
-    readonly "video/webm": readonly ["webm"];
-    readonly "video/x-f4v": readonly ["f4v"];
-    readonly "video/x-fli": readonly ["fli"];
-    readonly "video/x-flv": readonly ["flv"];
-    readonly "video/x-m4v": readonly ["m4v"];
-    readonly "video/x-matroska": readonly ["mkv", "mk3d", "mks"];
-    readonly "video/x-mng": readonly ["mng"];
-    readonly "video/x-ms-asf": readonly ["asf", "asx"];
-    readonly "video/x-ms-vob": readonly ["vob"];
-    readonly "video/x-ms-wm": readonly ["wm"];
-    readonly "video/x-ms-wmv": readonly ["wmv"];
-    readonly "video/x-ms-wmx": readonly ["wmx"];
-    readonly "video/x-ms-wvx": readonly ["wvx"];
-    readonly "video/x-msvideo": readonly ["avi"];
-    readonly "video/x-sgi-movie": readonly ["movie"];
-    readonly "video/x-smv": readonly ["smv"];
+  readonly "application/mp4": readonly ["mp4s", "m4p"];
+  readonly "application/ogg": readonly ["ogx"];
+  readonly "application/vnd.apple.mpegurl": readonly ["m3u8"];
+  readonly "audio/3gpp": readonly ["*3gpp"];
+  readonly "audio/adpcm": readonly ["adp"];
+  readonly "audio/amr": readonly ["amr"];
+  readonly "audio/basic": readonly ["au", "snd"];
+  readonly "audio/midi": readonly ["mid", "midi", "kar", "rmi"];
+  readonly "audio/mobile-xmf": readonly ["mxmf"];
+  readonly "audio/mp3": readonly ["*mp3"];
+  readonly "audio/mp4": readonly ["m4a", "mp4a"];
+  readonly "audio/mpeg": readonly ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"];
+  readonly "audio/ogg": readonly ["oga", "ogg", "spx", "opus"];
+  readonly "audio/s3m": readonly ["s3m"];
+  readonly "audio/silk": readonly ["sil"];
+  readonly "audio/vnd.dece.audio": readonly ["uva", "uvva"];
+  readonly "audio/vnd.digital-winds": readonly ["eol"];
+  readonly "audio/vnd.dra": readonly ["dra"];
+  readonly "audio/vnd.dts.hd": readonly ["dtshd"];
+  readonly "audio/vnd.dts": readonly ["dts"];
+  readonly "audio/vnd.lucent.voice": readonly ["lvp"];
+  readonly "audio/vnd.ms-playready.media.pya": readonly ["pya"];
+  readonly "audio/vnd.nuera.ecelp4800": readonly ["ecelp4800"];
+  readonly "audio/vnd.nuera.ecelp7470": readonly ["ecelp7470"];
+  readonly "audio/vnd.nuera.ecelp9600": readonly ["ecelp9600"];
+  readonly "audio/vnd.rip": readonly ["rip"];
+  readonly "audio/wav": readonly ["wav"];
+  readonly "audio/wave": readonly ["*wav"];
+  readonly "audio/webm": readonly ["weba"];
+  readonly "audio/x-aac": readonly ["aac"];
+  readonly "audio/x-aiff": readonly ["aif", "aiff", "aifc"];
+  readonly "audio/x-caf": readonly ["caf"];
+  readonly "audio/x-flac": readonly ["flac"];
+  readonly "audio/x-m4a": readonly ["*m4a"];
+  readonly "audio/x-matroska": readonly ["mka"];
+  readonly "audio/x-mpegurl": readonly ["m3u"];
+  readonly "audio/x-ms-wax": readonly ["wax"];
+  readonly "audio/x-ms-wma": readonly ["wma"];
+  readonly "audio/x-pn-realaudio-plugin": readonly ["rmp"];
+  readonly "audio/x-pn-realaudio": readonly ["ram", "ra"];
+  readonly "audio/x-realaudio": readonly ["*ra"];
+  readonly "audio/x-wav": readonly ["*wav"];
+  readonly "audio/xm": readonly ["xm"];
+  readonly "video/3gpp": readonly ["3gp", "3gpp"];
+  readonly "video/3gpp2": readonly ["3g2"];
+  readonly "video/h261": readonly ["h261"];
+  readonly "video/h263": readonly ["h263"];
+  readonly "video/h264": readonly ["h264"];
+  readonly "video/iso.segment": readonly ["m4s"];
+  readonly "video/jpeg": readonly ["jpgv"];
+  readonly "video/jpm": readonly ["*jpm", "jpgm"];
+  readonly "video/mj2": readonly ["mj2", "mjp2"];
+  readonly "video/mp2t": readonly ["ts"];
+  readonly "video/mp4": readonly ["mp4", "mp4v", "mpg4"];
+  readonly "video/mpeg": readonly ["mpeg", "mpg", "mpe", "m1v", "m2v"];
+  readonly "video/ogg": readonly ["ogv"];
+  readonly "video/quicktime": readonly ["qt", "mov"];
+  readonly "video/vnd.dece.hd": readonly ["uvh", "uvvh"];
+  readonly "video/vnd.dece.mobile": readonly ["uvm", "uvvm"];
+  readonly "video/vnd.dece.pd": readonly ["uvp", "uvvp"];
+  readonly "video/vnd.dece.sd": readonly ["uvs", "uvvs"];
+  readonly "video/vnd.dece.video": readonly ["uvv", "uvvv"];
+  readonly "video/vnd.dvb.file": readonly ["dvb"];
+  readonly "video/vnd.fvt": readonly ["fvt"];
+  readonly "video/vnd.mpegurl": readonly ["mxu", "m4u"];
+  readonly "video/vnd.ms-playready.media.pyv": readonly ["pyv"];
+  readonly "video/vnd.uvvu.mp4": readonly ["uvu", "uvvu"];
+  readonly "video/vnd.vivo": readonly ["viv"];
+  readonly "video/vp8": readonly ["vp8"];
+  readonly "video/webm": readonly ["webm"];
+  readonly "video/x-f4v": readonly ["f4v"];
+  readonly "video/x-fli": readonly ["fli"];
+  readonly "video/x-flv": readonly ["flv"];
+  readonly "video/x-m4v": readonly ["m4v"];
+  readonly "video/x-matroska": readonly ["mkv", "mk3d", "mks"];
+  readonly "video/x-mng": readonly ["mng"];
+  readonly "video/x-ms-asf": readonly ["asf", "asx"];
+  readonly "video/x-ms-vob": readonly ["vob"];
+  readonly "video/x-ms-wm": readonly ["wm"];
+  readonly "video/x-ms-wmv": readonly ["wmv"];
+  readonly "video/x-ms-wmx": readonly ["wmx"];
+  readonly "video/x-ms-wvx": readonly ["wvx"];
+  readonly "video/x-msvideo": readonly ["avi"];
+  readonly "video/x-sgi-movie": readonly ["movie"];
+  readonly "video/x-smv": readonly ["smv"];
 };
 
-type AudioExtension = "m4a" | "mp4a" | "mpga" | "mp2" | "mp2a" | "mp3" | "m2a" | "m3a" | "wav" | "weba" | "aac" | "oga" | "spx";
+type AudioExtension =
+  | "m4a"
+  | "mp4a"
+  | "mpga"
+  | "mp2"
+  | "mp2a"
+  | "mp3"
+  | "m2a"
+  | "m3a"
+  | "wav"
+  | "weba"
+  | "aac"
+  | "oga"
+  | "spx";
 type VideoExtension = "mp4" | "ogv" | "webm" | "mov" | "m4v" | "avi" | "m3u8";
 type HlsExtension = "m3u8";
 type VideoTextTrackExtension = "vtt";
 type OptionalQueryParams = `?${string}` | "";
 type BaseSrc = {
-    type: "audio" | "video" | "hls" | "webrtc" | "image" | "vtt";
-    src: string;
-    mime: MimeType | null;
-    width: number | null;
-    height: number | null;
+  type: "audio" | "video" | "hls" | "webrtc" | "image" | "vtt";
+  src: string;
+  mime: MimeType | null;
+  width: number | null;
+  height: number | null;
 };
 interface AudioSrc extends BaseSrc {
-    type: "audio";
-    src: `${string}${AudioExtension}${OptionalQueryParams}`;
+  type: "audio";
+  src: `${string}${AudioExtension}${OptionalQueryParams}`;
 }
 interface VideoSrc extends BaseSrc {
-    type: "video";
-    src: `${string}${VideoExtension}${OptionalQueryParams}`;
+  type: "video";
+  src: `${string}${VideoExtension}${OptionalQueryParams}`;
 }
 interface ImageSrc extends BaseSrc {
-    type: "image";
-    src: `${string}${OptionalQueryParams}`;
+  type: "image";
+  src: `${string}${OptionalQueryParams}`;
 }
 interface VideoTextTrackSrc extends BaseSrc {
-    type: "vtt";
-    src: `${string}${VideoTextTrackExtension}${OptionalQueryParams}`;
+  type: "vtt";
+  src: `${string}${VideoTextTrackExtension}${OptionalQueryParams}`;
 }
 interface Base64Src extends BaseSrc {
-    type: "video";
-    src: `${string}`;
+  type: "video";
+  src: `${string}`;
 }
 interface HlsSrc extends BaseSrc {
-    type: "hls";
-    src: `${string}${HlsExtension}${OptionalQueryParams}`;
+  type: "hls";
+  src: `${string}${HlsExtension}${OptionalQueryParams}`;
 }
 interface WebRTCSrc extends BaseSrc {
-    type: "webrtc";
-    src: `${string}${OptionalQueryParams}`;
+  type: "webrtc";
+  src: `${string}${OptionalQueryParams}`;
 }
 interface FlvSrc extends BaseSrc {
-    type: "video";
-    src: `${string}`;
+  type: "video";
+  src: `${string}`;
 }
-type Src = AudioSrc | HlsSrc | FlvSrc | VideoSrc | Base64Src | WebRTCSrc | ImageSrc | VideoTextTrackSrc;
+type Src =
+  | AudioSrc
+  | HlsSrc
+  | FlvSrc
+  | VideoSrc
+  | Base64Src
+  | WebRTCSrc
+  | ImageSrc
+  | VideoTextTrackSrc;
 type AccessControlParams = {
-    jwt?: string | null;
-    accessKey?: string | null;
+  jwt?: string | null;
+  accessKey?: string | null;
 };
-type VideoQuality = "1080p" | "720p" | "480p" | "360p" | "240p" | "144p" | "auto";
+type VideoQuality =
+  | "1080p"
+  | "720p"
+  | "480p"
+  | "360p"
+  | "240p"
+  | "144p"
+  | "auto";
 /**
  * Represents a single track selector
  */
-type SingleTrackSelector = 
-/** Selects no tracks */
-"none"
-/** Selects all tracks */
- | "all"
-/** Selects all tracks */
- | "*"
-/** Specific track ID */
- | `${number}`
-/** Highest bit rate */
- | "maxbps"
-/** Lowest bit rate */
- | "minbps"
-/** Specific bit rate */
- | `${number}bps`
-/** Specific bit rate */
- | `${number}kbps`
-/** Specific bit rate */
- | `${number}mbps`
-/** Greater than specific bit rate */
- | `>${number}bps`
-/** Greater than specific bit rate */
- | `>${number}kbps`
-/** Greater than specific bit rate */
- | `>${number}mbps`
-/** Less than specific bit rate */
- | `<${number}bps`
-/** Less than specific bit rate */
- | `<${number}kbps`
-/** Less than specific bit rate */
- | `<${number}mbps`
-/** Max less than specific bit rate */
- | `max<${number}bps`
-/** Max less than specific bit rate */
- | `max<${number}kbps`
-/** Max less than specific bit rate */
- | `max<${number}mbps`;
+type SingleTrackSelector =
+  /** Selects no tracks */
+  | "none"
+  /** Selects all tracks */
+  | "all"
+  /** Selects all tracks */
+  | "*"
+  /** Specific track ID */
+  | `${number}`
+  /** Highest bit rate */
+  | "maxbps"
+  /** Lowest bit rate */
+  | "minbps"
+  /** Specific bit rate */
+  | `${number}bps`
+  /** Specific bit rate */
+  | `${number}kbps`
+  /** Specific bit rate */
+  | `${number}mbps`
+  /** Greater than specific bit rate */
+  | `>${number}bps`
+  /** Greater than specific bit rate */
+  | `>${number}kbps`
+  /** Greater than specific bit rate */
+  | `>${number}mbps`
+  /** Less than specific bit rate */
+  | `<${number}bps`
+  /** Less than specific bit rate */
+  | `<${number}kbps`
+  /** Less than specific bit rate */
+  | `<${number}mbps`
+  /** Max less than specific bit rate */
+  | `max<${number}bps`
+  /** Max less than specific bit rate */
+  | `max<${number}kbps`
+  /** Max less than specific bit rate */
+  | `max<${number}mbps`;
 /**
  * Represents a single audio track selector
  */
-type SingleAudioTrackSelector = SingleTrackSelector
-/** Channel count */
- | "surround"
-/** Channel count */
- | "mono"
-/** Channel count */
- | "stereo"
-/** Channel count */
- | `${number}ch`;
+type SingleAudioTrackSelector =
+  | SingleTrackSelector
+  /** Channel count */
+  | "surround"
+  /** Channel count */
+  | "mono"
+  /** Channel count */
+  | "stereo"
+  /** Channel count */
+  | `${number}ch`;
 /**
  * Represents a single video track selector
  */
-type SingleVideoTrackSelector = SingleTrackSelector
-/** Highest pixel surface area */
- | "maxres"
-/** Lowest pixel surface area */
- | "minres"
-/** Specific pixel surface area */
- | `${number}x${number}`
-/** Closest to specific pixel surface area */
- | `~${number}x${number}`
-/** Greater than pixel surface area */
- | `>${number}x${number}`
-/** Less than pixel surface area */
- | `<${number}x${number}`
-/** Resolution */
- | "720p"
-/** Resolution */
- | "1080p"
-/** Resolution */
- | "1440p"
-/** Resolution */
- | "2k"
-/** Resolution */
- | "4k"
-/** Resolution */
- | "5k"
-/** Resolution */
- | "8k";
+type SingleVideoTrackSelector =
+  | SingleTrackSelector
+  /** Highest pixel surface area */
+  | "maxres"
+  /** Lowest pixel surface area */
+  | "minres"
+  /** Specific pixel surface area */
+  | `${number}x${number}`
+  /** Closest to specific pixel surface area */
+  | `~${number}x${number}`
+  /** Greater than pixel surface area */
+  | `>${number}x${number}`
+  /** Less than pixel surface area */
+  | `<${number}x${number}`
+  /** Resolution */
+  | "720p"
+  /** Resolution */
+  | "1080p"
+  /** Resolution */
+  | "1440p"
+  /** Resolution */
+  | "2k"
+  /** Resolution */
+  | "4k"
+  /** Resolution */
+  | "5k"
+  /** Resolution */
+  | "8k";
 /**
  * Generic track selector for a given type
  */
-type TrackSelector<T extends string> = T
-/** Union of selectors */
- | `${T},${T}`
-/** Difference of selectors */
- | `${T},!${T}`
-/** Intersection of selectors */
- | `${T},|${T}`;
+type TrackSelector<T extends string> =
+  | T
+  /** Union of selectors */
+  | `${T},${T}`
+  /** Difference of selectors */
+  | `${T},!${T}`
+  /** Intersection of selectors */
+  | `${T},|${T}`;
 type VideoTrackSelector = TrackSelector<SingleVideoTrackSelector>;
 type AudioTrackSelector = TrackSelector<SingleAudioTrackSelector>;
-declare const getMediaSourceType: (src: string | null, opts?: {
+declare const getMediaSourceType: (
+  src: string | null,
+  opts?: {
     sizing?: ElementSize;
-}) => Src | null;
+  }
+) => Src | null;
 
 type ClientStorage = {
-    getItem: <T>(key: string, defaultState?: T | null) => Promise<T | null>;
-    setItem: <T>(key: string, value: T | null) => Promise<void>;
-    removeItem: (key: string) => Promise<void>;
+  getItem: <T>(key: string, defaultState?: T | null) => Promise<T | null>;
+  setItem: <T>(key: string, value: T | null) => Promise<void>;
+  removeItem: (key: string) => Promise<void>;
 };
 
 type InitialProps = {
-    /**
-     * An access key to be used for playback. This key grants permission to play access key protected media.
-     */
-    accessKey: string | null;
-    /** The aspect ratio for the container element. Defines the width to height ratio of the player, like 16:9 or 4:3. */
-    aspectRatio: number | null;
-    /**
-     * If `autoPlay` was passed in to the Player. Determines if the media should attempt to start playing automatically on load.
-     *
-     * Autoplay for videos in modern browsers typically works only if the video is muted or if the user has previously interacted with the website.
-     *
-     * @link https://developer.chrome.com/blog/autoplay/
-     */
-    autoPlay: boolean;
-    /**
-     * Controls the initial value for exponential backoff, in ms. Defaults to 500ms, which is subsequently multiplied by 2^n power on each error.
-     *
-     * This is limited at a minimum of 100ms.
-     */
-    backoff: number;
-    /**
-     * Controls the maximum backoff when an error is encountered, in ms. Defaults to 30s.
-     *
-     * This is limited at a minimum of 10s, to prevent DDoS when a popular stream goes down.
-     */
-    backoffMax: number;
-    /**
-     * The length of the clip. This is usually used alongside `ClipTrigger`. Specifies the duration of the media clip, in seconds.
-     *
-     * Set to `null` to disable the ClipTrigger.
-     */
-    clipLength: ClipLength | null;
-    /**
-     * How long to cache WebRTC timeouts for faster subsequent playbacks after a timeout.
-     *
-     * Set to a number, in ms, to enable caching.
-     */
-    cacheWebRTCFailureMs: number | null;
-    /**
-     * Whether hotkeys are enabled. Defaults to `true`. Allows users to use keyboard shortcuts for player control.
-     *
-     * This is highly recommended to adhere to ARIA guidelines.
-     */
-    hotkeys: boolean | "broadcast";
-    /**
-     * The JWT (JSON Web Token) which is passed along to allow playback of an asset. Used for authentication and information exchange.
-     */
-    jwt: string | null;
-    /**
-     * Whether low latency is enabled for live-streaming. `force` can be used to require low latency playback using WebRTC, with no fallback to HLS. Defaults to `true`,
-     * which means that WebRTC is enabled by default, with fallback to HLS.
-     */
-    lowLatency: boolean | "force";
-    /**
-     * Callback called when there is an error. When `null` is passed, it indicates that the error has been resolved.
-     */
-    onError: ((error: PlaybackError | null) => void) | null;
-    /**
-     * The default playback rate for the media. Determines the speed at which the media is played, e.g. 0.5 for half-speed, 2 for double speed.
-     *
-     * This can be overridden during playback by the user with `RateSelect`.
-     *
-     * `constant` means the speed of live stream playback will remain consistent, instead of speeding up to catch up with the head of the stream.
-     */
-    playbackRate: PlaybackRate;
-    /**
-     * Controls how often the poster image updates when playing back a livestream, in ms. Set to `0` to disable. Defaults to 30s.
-     */
-    posterLiveUpdate: number;
-    /**
-     * The preload option passed in to the Player. Specifies how the media should be preloaded: 'auto', 'metadata', or 'none'.
-     *
-     * @link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video
-     */
-    preload: "auto" | "metadata" | "none";
-    /**
-     * The timeout for playback before falling back to the next source. This includes SDP negotiation for WebRTC, waiting for WebRTC to play,
-     * and responses from the server.
-     *
-     * In milliseconds - defaults to 10000.
-     */
-    timeout: number;
-    /**
-     * The storage option for saving persistent state, like volume and video quality.
-     *
-     * Defaults to `localStorage` in the browser. Pass `null` to disable storage.
-     */
-    storage: ClientStorage | null;
-    /**
-     * The default video quality for playback.
-     *
-     * This is overridden when a user changes it, and their preferences are, by default, saved to storage.
-     */
-    videoQuality: VideoQuality;
-    /**
-     * The default volume level of the media, ranging from 0 (muted) to 1 (maximum volume).
-     *
-     * This is overridden when a user changes it, and their preferences are, by default, saved to storage.
-     */
-    volume: number;
-    /**
-     * The viewerId for the viewer. A unique identifier for the user or session watching the media.
-     */
-    viewerId: string | null;
+  /**
+   * An access key to be used for playback. This key grants permission to play access key protected media.
+   */
+  accessKey: string | null;
+  /** The aspect ratio for the container element. Defines the width to height ratio of the player, like 16:9 or 4:3. */
+  aspectRatio: number | null;
+  /**
+   * If `autoPlay` was passed in to the Player. Determines if the media should attempt to start playing automatically on load.
+   *
+   * Autoplay for videos in modern browsers typically works only if the video is muted or if the user has previously interacted with the website.
+   *
+   * @link https://developer.chrome.com/blog/autoplay/
+   */
+  autoPlay: boolean;
+  /**
+   * Controls the initial value for exponential backoff, in ms. Defaults to 500ms, which is subsequently multiplied by 2^n power on each error.
+   *
+   * This is limited at a minimum of 100ms.
+   */
+  backoff: number;
+  /**
+   * Controls the maximum backoff when an error is encountered, in ms. Defaults to 30s.
+   *
+   * This is limited at a minimum of 10s, to prevent DDoS when a popular stream goes down.
+   */
+  backoffMax: number;
+  /**
+   * The length of the clip. This is usually used alongside `ClipTrigger`. Specifies the duration of the media clip, in seconds.
+   *
+   * Set to `null` to disable the ClipTrigger.
+   */
+  clipLength: ClipLength | null;
+  /**
+   * If true, won't append the token to the playback URL.
+   */
+  forceNoToken?: boolean;
+  /**
+   * How long to cache WebRTC timeouts for faster subsequent playbacks after a timeout.
+   *
+   * Set to a number, in ms, to enable caching.
+   */
+  cacheWebRTCFailureMs: number | null;
+  /**
+   * Whether hotkeys are enabled. Defaults to `true`. Allows users to use keyboard shortcuts for player control.
+   *
+   * This is highly recommended to adhere to ARIA guidelines.
+   */
+  hotkeys: boolean | "broadcast";
+  /**
+   * The JWT (JSON Web Token) which is passed along to allow playback of an asset. Used for authentication and information exchange.
+   */
+  jwt: string | null;
+  /**
+   * Whether low latency is enabled for live-streaming. `force` can be used to require low latency playback using WebRTC, with no fallback to HLS. Defaults to `true`,
+   * which means that WebRTC is enabled by default, with fallback to HLS.
+   */
+  lowLatency: boolean | "force";
+  /**
+   * Callback called when there is an error. When `null` is passed, it indicates that the error has been resolved.
+   */
+  onError: ((error: PlaybackError | null) => void) | null;
+  /**
+   * The default playback rate for the media. Determines the speed at which the media is played, e.g. 0.5 for half-speed, 2 for double speed.
+   *
+   * This can be overridden during playback by the user with `RateSelect`.
+   *
+   * `constant` means the speed of live stream playback will remain consistent, instead of speeding up to catch up with the head of the stream.
+   */
+  playbackRate: PlaybackRate;
+  /**
+   * Controls how often the poster image updates when playing back a livestream, in ms. Set to `0` to disable. Defaults to 30s.
+   */
+  posterLiveUpdate: number;
+  /**
+   * The preload option passed in to the Player. Specifies how the media should be preloaded: 'auto', 'metadata', or 'none'.
+   *
+   * @link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video
+   */
+  preload: "auto" | "metadata" | "none";
+  /**
+   * The timeout for playback before falling back to the next source. This includes SDP negotiation for WebRTC, waiting for WebRTC to play,
+   * and responses from the server.
+   *
+   * In milliseconds - defaults to 10000.
+   */
+  timeout: number;
+  /**
+   * The storage option for saving persistent state, like volume and video quality.
+   *
+   * Defaults to `localStorage` in the browser. Pass `null` to disable storage.
+   */
+  storage: ClientStorage | null;
+  /**
+   * The default video quality for playback.
+   *
+   * This is overridden when a user changes it, and their preferences are, by default, saved to storage.
+   */
+  videoQuality: VideoQuality;
+  /**
+   * The default volume level of the media, ranging from 0 (muted) to 1 (maximum volume).
+   *
+   * This is overridden when a user changes it, and their preferences are, by default, saved to storage.
+   */
+  volume: number;
+  /**
+   * The viewerId for the viewer. A unique identifier for the user or session watching the media.
+   */
+  viewerId: string | null;
 };
 type DeviceInformation = {
-    version: string;
-    isMobile: boolean;
-    isIos: boolean;
-    isAndroid: boolean;
-    userAgent: string;
-    screenWidth: number | null;
-    /** If the media supports changing the volume */
-    isVolumeChangeSupported: boolean;
-    /** If the media supports PiP */
-    isPictureInPictureSupported: boolean;
-    /** If the media supports fullscreen */
-    isFullscreenSupported: boolean;
-    /** If the media supports HLS playback */
-    isHlsSupported: boolean;
-    /** If the media supports WebRTC */
-    isWebRTCSupported: boolean;
+  version: string;
+  isMobile: boolean;
+  isIos: boolean;
+  isAndroid: boolean;
+  userAgent: string;
+  screenWidth: number | null;
+  /** If the media supports changing the volume */
+  isVolumeChangeSupported: boolean;
+  /** If the media supports PiP */
+  isPictureInPictureSupported: boolean;
+  /** If the media supports fullscreen */
+  isFullscreenSupported: boolean;
+  /** If the media supports HLS playback */
+  isHlsSupported: boolean;
+  /** If the media supports WebRTC */
+  isWebRTCSupported: boolean;
 };
 type ClipParams = {
-    startTime: number;
-    endTime: number;
+  startTime: number;
+  endTime: number;
 };
 type ControlsState = {
-    /** The last time that play/pause was requested */
-    requestedPlayPauseLastTime: number;
-    /** The last time that fullscreen was changed */
-    requestedFullscreenLastTime: number;
-    /** The last time that picture in picture was changed */
-    requestedPictureInPictureLastTime: number;
-    /** The last time that the element was measured */
-    requestedMeasureLastTime: number;
-    /** Internal value when a user requests an update to the progress of the media */
-    requestedRangeToSeekTo: number;
-    /** The params for the latest clip request. */
-    requestedClipParams: ClipParams | null;
-    /** The parsed thumbnail URL for the media. */
-    thumbnail: ImageSrc | null;
-    /** The last time that a play event was received */
-    playLastTime: number;
-    /** The last time that a pause event was received */
-    pauseLastTime: number;
-    /** The offset of the browser's livestream versus the server time (in ms). */
-    playbackOffsetMs: number | null;
-    /** The last time that the media was interacted with */
-    lastInteraction: number;
-    /** The parsed playbackId from the src */
-    playbackId: string | null;
-    /** The last time that an error occurred */
-    lastError: number;
-    /** Media sizing information */
-    size: MediaSizing | null;
-    /** If the volume is muted */
-    muted: boolean;
-    /** The volume, doesn't change when muted */
-    volume: number;
-    /** Session token for the current playback */
-    sessionToken: string;
-    /**
-     * Configures the HLS options, for advanced usage of the Player.
-     */
-    hlsConfig: any | null;
-    /**
-     * Auto-hide controls after a set amount of time (in milliseconds).
-     *
-     * Defaults to 3000. Set to 0 for no hiding.
-     */
-    autohide: number;
+  /** The last time that play/pause was requested */
+  requestedPlayPauseLastTime: number;
+  /** The last time that fullscreen was changed */
+  requestedFullscreenLastTime: number;
+  /** The last time that picture in picture was changed */
+  requestedPictureInPictureLastTime: number;
+  /** The last time that the element was measured */
+  requestedMeasureLastTime: number;
+  /** Internal value when a user requests an update to the progress of the media */
+  requestedRangeToSeekTo: number;
+  /** The params for the latest clip request. */
+  requestedClipParams: ClipParams | null;
+  /** The parsed thumbnail URL for the media. */
+  thumbnail: ImageSrc | null;
+  /** The last time that a play event was received */
+  playLastTime: number;
+  /** The last time that a pause event was received */
+  pauseLastTime: number;
+  /** The offset of the browser's livestream versus the server time (in ms). */
+  playbackOffsetMs: number | null;
+  /** The last time that the media was interacted with */
+  lastInteraction: number;
+  /** The parsed playbackId from the src */
+  playbackId: string | null;
+  /** The last time that an error occurred */
+  lastError: number;
+  /** Media sizing information */
+  size: MediaSizing | null;
+  /** If the volume is muted */
+  muted: boolean;
+  /** The volume, doesn't change when muted */
+  volume: number;
+  /** Session token for the current playback */
+  sessionToken: string;
+  /**
+   * Configures the HLS options, for advanced usage of the Player.
+   */
+  hlsConfig: any | null;
+  /**
+   * Auto-hide controls after a set amount of time (in milliseconds).
+   *
+   * Defaults to 3000. Set to 0 for no hiding.
+   */
+  autohide: number;
 };
 type ObjectFit = "cover" | "contain";
 type PlaybackError = {
-    type: "offline" | "access-control" | "fallback" | "permissions" | "unknown";
-    message: string;
+  type: "offline" | "access-control" | "fallback" | "permissions" | "unknown";
+  message: string;
 };
 type MediaSizing = {
-    container?: ElementSize;
-    media?: ElementSize;
-    window?: ElementSize;
+  container?: ElementSize;
+  media?: ElementSize;
+  window?: ElementSize;
 };
 type ElementSize = {
-    width: number;
-    height: number;
+  width: number;
+  height: number;
 };
 type MetaTrack = {
-    bps?: number;
-    channels?: number;
-    codec?: string;
-    codecstring?: string;
-    firstms?: number;
-    idx?: number;
-    init?: string;
-    jitter?: number;
-    lastms?: number;
-    maxbps?: number;
-    rate?: number;
-    size?: number;
-    trackid?: number;
-    type?: string;
-    height?: number;
-    width?: number;
-    fpks?: number;
-    bframes?: number;
+  bps?: number;
+  channels?: number;
+  codec?: string;
+  codecstring?: string;
+  firstms?: number;
+  idx?: number;
+  init?: string;
+  jitter?: number;
+  lastms?: number;
+  maxbps?: number;
+  rate?: number;
+  size?: number;
+  trackid?: number;
+  type?: string;
+  height?: number;
+  width?: number;
+  fpks?: number;
+  bframes?: number;
 };
 type Meta = {
-    bframes?: number;
-    buffer_window?: number;
-    jitter?: number;
-    live?: number;
-    maxkeepaway?: number;
-    tracks?: {
-        [key: string]: MetaTrack;
-    };
-    uuid?: string;
-    version?: number;
+  bframes?: number;
+  buffer_window?: number;
+  jitter?: number;
+  live?: number;
+  maxkeepaway?: number;
+  tracks?: {
+    [key: string]: MetaTrack;
+  };
+  uuid?: string;
+  version?: number;
 };
 type Source = {
-    priority?: number;
-    relurl?: string;
-    simul_tracks?: number;
-    total_matches?: number;
-    type?: string;
-    url?: string;
-    hrn?: string;
-    player_url?: string;
-    RTCIceServers?: {
-        urls?: string;
-        credential?: string;
-        username?: string;
-    }[];
+  priority?: number;
+  relurl?: string;
+  simul_tracks?: number;
+  total_matches?: number;
+  type?: string;
+  url?: string;
+  hrn?: string;
+  player_url?: string;
+  RTCIceServers?: {
+    urls?: string;
+    credential?: string;
+    username?: string;
+  }[];
 };
 type Metadata = {
-    height?: number;
-    meta?: Meta;
-    selver?: number;
-    source?: Source[];
-    type?: string;
-    unixoffset?: number;
-    width?: number;
+  height?: number;
+  meta?: Meta;
+  selver?: number;
+  source?: Source[];
+  type?: string;
+  unixoffset?: number;
+  width?: number;
 };
 type ClipLength = 90 | 60 | 45 | 30 | 15 | 10;
 /**
@@ -493,237 +531,265 @@ type ClipLength = 90 | 60 | 45 | 30 | 15 | 10;
  */
 type PlaybackRate = number | "constant";
 type AriaText = {
-    progress: string;
-    pictureInPicture: string;
-    fullscreen: string;
-    playPause: string;
-    clip: string | null;
-    time: string;
+  progress: string;
+  pictureInPicture: string;
+  fullscreen: string;
+  playPause: string;
+  clip: string | null;
+  time: string;
 };
 type MediaControllerState = {
-    /** The ARIA text for the current state */
-    aria: AriaText;
-    /** Current buffered end time for the media (in seconds) */
-    buffered: number;
-    /** Current buffered percent */
-    bufferedPercent: number;
-    /** If the media has loaded and can be played */
-    canPlay: boolean;
-    /** The current source that is playing. */
-    currentSource: Src | null;
-    /** The final playback URL for the media that is playing, after redirects. */
-    currentUrl: string | null;
-    /** Current total duration of the media (in seconds) */
-    duration: number;
-    /** If the media has experienced an error. */
-    error: PlaybackError | null;
-    /** The number of errors that have occurred. */
-    errorCount: number;
-    /** If the media is currently stalled */
-    stalled: boolean;
-    /** If the media is fullscreen. */
-    fullscreen: boolean;
-    /** If the media has been played yet */
-    hasPlayed: boolean;
-    /** If all controls are currently hidden */
-    hidden: boolean;
-    /** If the content is live media */
-    live: boolean;
-    /** If the media is currently loading */
-    loading: boolean;
-    /** The metrics reporting URL to POST to. */
-    metricsReportingUrl: string | null;
-    /** If the video element is mounted on the DOM - this is used for initialization logic */
-    mounted: boolean;
-    /** The current playback rate for the media. Defaults to 1. */
-    playbackRate: PlaybackRate;
-    /** If the media is in picture in picture mode */
-    pictureInPicture: boolean;
-    /** The poster image URL for the media. */
-    poster: string | null;
-    /** Current progress of the media (in seconds) */
-    progress: number;
-    /** If the media is current playing or paused */
-    playing: boolean;
-    /** The sorted sources that were passed in to the Player */
-    sortedSources: Src[] | string | null;
-    /** Current volume of the media. 0 if it is muted. */
-    volume: number;
-    /** If the media is currently waiting for data */
-    waiting: boolean;
-    /** The quality of the video playback. */
-    videoQuality: VideoQuality;
-    /** If the media has ended */
-    ended: boolean;
-    __controls: ControlsState;
-    __controlsFunctions: {
-        setHidden: (hidden: boolean) => void;
-        onCanPlay: () => void;
-        onDurationChange: (duration: number) => void;
-        onEnded: () => void;
-        onError: (error: Error | null) => void;
-        onFinalUrl: (url: string | null) => void;
-        onLoading: () => void;
-        onPause: () => void;
-        onPlay: () => void;
-        onProgress: (time: number) => void;
-        onStalled: () => void;
-        onWaiting: () => void;
-        onWebRTCTimeout: () => void;
-        requestClip: () => void;
-        requestMeasure: () => void;
-        requestSeek: (time: number) => void;
-        requestSeekBack: (difference?: number) => void;
-        requestSeekDiff: (difference: number) => void;
-        requestSeekForward: (difference?: number) => void;
-        requestToggleFullscreen: () => void;
-        requestToggleMute: (forceValue?: boolean) => void;
-        requestTogglePictureInPicture: () => void;
-        requestVolume: (volume: number) => void;
-        setAutohide: (autohide: number) => void;
-        setFullscreen: (fullscreen: boolean) => void;
-        setHlsConfig: (hlsConfig: any) => void;
-        setLive: (live: boolean) => void;
-        setMetricsReportingUrl: (url: string) => void;
-        setMounted: () => void;
-        setPictureInPicture: (pictureInPicture: boolean) => void;
-        setPlaybackRate: (rate: number | string) => void;
-        setPoster: (poster: string | null) => void;
-        setVideoQuality: (videoQuality: VideoQuality) => void;
-        setSize: (size: Partial<MediaSizing>) => void;
-        setVolume: (volume: number) => void;
-        setWebsocketMetadata: (metadata: Metadata) => void;
-        togglePlay: (force?: boolean) => void;
-        updateBuffered: (buffered: number) => void;
-        updateLastInteraction: () => void;
-        updatePlaybackOffsetMs: (offset: number) => void;
-    };
-    /** The device information and support. */
-    __device: DeviceInformation;
-    /** The initial props passed into the component. */
-    __initialProps: InitialProps;
-    __metadata: Metadata | null;
+  /** The ARIA text for the current state */
+  aria: AriaText;
+  /** Current buffered end time for the media (in seconds) */
+  buffered: number;
+  /** Current buffered percent */
+  bufferedPercent: number;
+  /** If the media has loaded and can be played */
+  canPlay: boolean;
+  /** The current source that is playing. */
+  currentSource: Src | null;
+  /** The final playback URL for the media that is playing, after redirects. */
+  currentUrl: string | null;
+  /** Current total duration of the media (in seconds) */
+  duration: number;
+  /** If the media has experienced an error. */
+  error: PlaybackError | null;
+  /** The number of errors that have occurred. */
+  errorCount: number;
+  /** If the media is currently stalled */
+  stalled: boolean;
+  /** If the media is fullscreen. */
+  fullscreen: boolean;
+  /** If the media has been played yet */
+  hasPlayed: boolean;
+  /** If all controls are currently hidden */
+  hidden: boolean;
+  /** If the content is live media */
+  live: boolean;
+  /** If the media is currently loading */
+  loading: boolean;
+  /** The metrics reporting URL to POST to. */
+  metricsReportingUrl: string | null;
+  /** If the video element is mounted on the DOM - this is used for initialization logic */
+  mounted: boolean;
+  /** The current playback rate for the media. Defaults to 1. */
+  playbackRate: PlaybackRate;
+  /** If the media is in picture in picture mode */
+  pictureInPicture: boolean;
+  /** The poster image URL for the media. */
+  poster: string | null;
+  /** Current progress of the media (in seconds) */
+  progress: number;
+  /** If the media is current playing or paused */
+  playing: boolean;
+  /** The sorted sources that were passed in to the Player */
+  sortedSources: Src[] | string | null;
+  /** Current volume of the media. 0 if it is muted. */
+  volume: number;
+  /** If the media is currently waiting for data */
+  waiting: boolean;
+  /** The quality of the video playback. */
+  videoQuality: VideoQuality;
+  /** If the media has ended */
+  ended: boolean;
+  __controls: ControlsState;
+  __controlsFunctions: {
+    setHidden: (hidden: boolean) => void;
+    onCanPlay: () => void;
+    onDurationChange: (duration: number) => void;
+    onEnded: () => void;
+    onError: (error: Error | null) => void;
+    onFinalUrl: (url: string | null) => void;
+    onLoading: () => void;
+    onPause: () => void;
+    onPlay: () => void;
+    onProgress: (time: number) => void;
+    onStalled: () => void;
+    onWaiting: () => void;
+    onWebRTCTimeout: () => void;
+    requestClip: () => void;
+    requestMeasure: () => void;
+    requestSeek: (time: number) => void;
+    requestSeekBack: (difference?: number) => void;
+    requestSeekDiff: (difference: number) => void;
+    requestSeekForward: (difference?: number) => void;
+    requestToggleFullscreen: () => void;
+    requestToggleMute: (forceValue?: boolean) => void;
+    requestTogglePictureInPicture: () => void;
+    requestVolume: (volume: number) => void;
+    setAutohide: (autohide: number) => void;
+    setFullscreen: (fullscreen: boolean) => void;
+    setHlsConfig: (hlsConfig: any) => void;
+    setLive: (live: boolean) => void;
+    setMetricsReportingUrl: (url: string) => void;
+    setMounted: () => void;
+    setPictureInPicture: (pictureInPicture: boolean) => void;
+    setPlaybackRate: (rate: number | string) => void;
+    setPoster: (poster: string | null) => void;
+    setVideoQuality: (videoQuality: VideoQuality) => void;
+    setSize: (size: Partial<MediaSizing>) => void;
+    setVolume: (volume: number) => void;
+    setWebsocketMetadata: (metadata: Metadata) => void;
+    togglePlay: (force?: boolean) => void;
+    updateBuffered: (buffered: number) => void;
+    updateLastInteraction: () => void;
+    updatePlaybackOffsetMs: (offset: number) => void;
+  };
+  /** The device information and support. */
+  __device: DeviceInformation;
+  /** The initial props passed into the component. */
+  __initialProps: InitialProps;
+  __metadata: Metadata | null;
 };
 type MediaControllerStore = StoreApi<MediaControllerState> & {
-    subscribe: {
-        (listener: (selectedState: MediaControllerState, previousSelectedState: MediaControllerState) => void): () => void;
-        <U>(selector: (state: MediaControllerState) => U, listener: (selectedState: U, previousSelectedState: U) => void, options?: {
-            equalityFn?: (a: U, b: U) => boolean;
-            fireImmediately?: boolean;
-        }): () => void;
-    };
-    persist: {
-        onFinishHydration: (fn: (state: MediaControllerState) => void) => () => void;
-    };
-};
-declare const createControllerStore: ({ device, storage, src, initialProps, playbackId, }: {
-    device: DeviceInformation;
-    storage: ClientStorage;
-    src: Src[] | string | null;
-    initialProps: Partial<InitialProps>;
-    playbackId?: string;
+  subscribe: {
+    (
+      listener: (
+        selectedState: MediaControllerState,
+        previousSelectedState: MediaControllerState
+      ) => void
+    ): () => void;
+    <U>(
+      selector: (state: MediaControllerState) => U,
+      listener: (selectedState: U, previousSelectedState: U) => void,
+      options?: {
+        equalityFn?: (a: U, b: U) => boolean;
+        fireImmediately?: boolean;
+      }
+    ): () => void;
+  };
+  persist: {
+    onFinishHydration: (
+      fn: (state: MediaControllerState) => void
+    ) => () => void;
+  };
+};
+declare const createControllerStore: ({
+  device,
+  storage,
+  src,
+  initialProps,
+  playbackId,
+}: {
+  device: DeviceInformation;
+  storage: ClientStorage;
+  src: Src[] | string | null;
+  initialProps: Partial<InitialProps>;
+  playbackId?: string;
 }) => {
-    store: MediaControllerStore;
-    destroy: () => void;
+  store: MediaControllerStore;
+  destroy: () => void;
 };
 
 type MetricsOpts = {
-    /**
-     * Disables the `progress` event listener, which is used to monitor when media is in a "playing" state.
-     */
-    disableProgressListener?: boolean;
+  /**
+   * Disables the `progress` event listener, which is used to monitor when media is in a "playing" state.
+   */
+  disableProgressListener?: boolean;
 };
 type RawMetrics = {
-    preloadTime: number | null;
-    ttff: number | null;
-    firstPlayback: number | null;
-    nWaiting: number | null;
-    timeWaiting: number;
-    nStalled: number | null;
-    timeStalled: number;
-    timeUnpaused: number;
-    nError: number | null;
-    lastError?: string;
-    videoHeight: number | null;
-    videoWidth: number | null;
-    playerHeight: number | null;
-    playerWidth: number | null;
-    playbackScore: number | null;
-    player: `${"audio" | "hls" | "video" | "webrtc" | "image" | "vtt" | "unknown"}-${string}`;
-    sourceType: MimeType | "unknown";
-    offset: number | null;
-    pageUrl: string;
-    sourceUrl: string | null;
-    duration: number | null;
-    autoplay: "autoplay" | "preload-full" | "preload-metadata" | "standard";
-    userAgent: string;
-    uid: string;
+  preloadTime: number | null;
+  ttff: number | null;
+  firstPlayback: number | null;
+  nWaiting: number | null;
+  timeWaiting: number;
+  nStalled: number | null;
+  timeStalled: number;
+  timeUnpaused: number;
+  nError: number | null;
+  lastError?: string;
+  videoHeight: number | null;
+  videoWidth: number | null;
+  playerHeight: number | null;
+  playerWidth: number | null;
+  playbackScore: number | null;
+  player: `${
+    | "audio"
+    | "hls"
+    | "video"
+    | "webrtc"
+    | "image"
+    | "vtt"
+    | "unknown"}-${string}`;
+  sourceType: MimeType | "unknown";
+  offset: number | null;
+  pageUrl: string;
+  sourceUrl: string | null;
+  duration: number | null;
+  autoplay: "autoplay" | "preload-full" | "preload-metadata" | "standard";
+  userAgent: string;
+  uid: string;
 };
 type PlaybackRecord = {
-    clockTime: number;
-    mediaTime: number;
-    score: number;
+  clockTime: number;
+  mediaTime: number;
+  score: number;
 };
 /**
  * @deprecated in favor of `addMetricsToStore`
  */
 declare class LegacyPlaybackMonitor {
-    active: boolean;
-    values: PlaybackRecord[];
-    score: number | null;
-    averagingSteps: number;
-    store: MediaControllerStore;
-    constructor(store: MediaControllerStore);
-    init(): void;
-    reset(): void;
-    destroy(): void;
-    calculateScore(): number | null;
-    valueToScore(a: PlaybackRecord, b?: PlaybackRecord): number;
+  active: boolean;
+  values: PlaybackRecord[];
+  score: number | null;
+  averagingSteps: number;
+  store: MediaControllerStore;
+  constructor(store: MediaControllerStore);
+  init(): void;
+  reset(): void;
+  destroy(): void;
+  calculateScore(): number | null;
+  valueToScore(a: PlaybackRecord, b?: PlaybackRecord): number;
 }
 declare class Timer {
-    totalTime: number;
-    countStarts: number;
-    startTime: number;
-    start(): void;
-    stop(): void;
-    getTotalTime(): number;
-    getCountStarts(): number;
+  totalTime: number;
+  countStarts: number;
+  startTime: number;
+  start(): void;
+  stop(): void;
+  getTotalTime(): number;
+  getCountStarts(): number;
 }
 /**
  * @deprecated in favor of `addMetricsToStore`
  */
 declare class LegacyMetricsStatus {
-    requestedPlayTime: number | null;
-    firstFrameTime: number | null;
-    bootMs: number;
-    retryCount: number;
-    connected: boolean;
-    store: MediaControllerStore;
-    destroy: () => void;
-    currentMetrics: RawMetrics;
-    previousMetrics: RawMetrics | null;
-    timeWaiting: Timer;
-    timeStalled: Timer;
-    timeUnpaused: Timer;
-    constructor(store: MediaControllerStore, bootMs: number, opts: MetricsOpts | undefined);
-    addError(error: string): void;
-    getFirstPlayback(): number | null;
-    setFirstPlayback(): void;
-    getFirstFrameTime(): number | null;
-    setFirstFrameTime(): void;
-    setPlaybackScore(playbackScore: number): void;
-    setConnected(isConnected: boolean): void;
-    getMetrics(): {
-        current: RawMetrics;
-        previous: RawMetrics | null;
-    };
+  requestedPlayTime: number | null;
+  firstFrameTime: number | null;
+  bootMs: number;
+  retryCount: number;
+  connected: boolean;
+  store: MediaControllerStore;
+  destroy: () => void;
+  currentMetrics: RawMetrics;
+  previousMetrics: RawMetrics | null;
+  timeWaiting: Timer;
+  timeStalled: Timer;
+  timeUnpaused: Timer;
+  constructor(
+    store: MediaControllerStore,
+    bootMs: number,
+    opts: MetricsOpts | undefined
+  );
+  addError(error: string): void;
+  getFirstPlayback(): number | null;
+  setFirstPlayback(): void;
+  getFirstFrameTime(): number | null;
+  setFirstFrameTime(): void;
+  setPlaybackScore(playbackScore: number): void;
+  setConnected(isConnected: boolean): void;
+  getMetrics(): {
+    current: RawMetrics;
+    previous: RawMetrics | null;
+  };
 }
 /**
  * @deprecated in favor of `addMetricsToStore`
  */
 type LegacyMediaMetrics = {
-    metrics: LegacyMetricsStatus | null;
-    destroy: () => void;
+  metrics: LegacyMetricsStatus | null;
+  destroy: () => void;
 };
 /**
  * Gather playback metrics from a media store and
@@ -733,150 +799,170 @@ type LegacyMediaMetrics = {
  * @param store Element to capture playback metrics from
  * @deprecated in favor of `addMetricsToStore`
  */
-declare function addLegacyMediaMetricsToStore(store: MediaControllerStore | undefined | null, opts?: MetricsOpts): LegacyMediaMetrics;
+declare function addLegacyMediaMetricsToStore(
+  store: MediaControllerStore | undefined | null,
+  opts?: MetricsOpts
+): LegacyMediaMetrics;
 
 type HeartbeatEvent = {
-    /** The event ID. */
-    id: string;
-    /** The event type. */
-    type: "heartbeat";
-    /** The timestamp of the event, in milliseconds. */
-    timestamp: number;
-    /** The number of errors that have occurred since last heartbeat. */
-    errors: number;
-    /** The number of warnings that have occurred since last heartbeat. */
-    warnings: number;
-    /** The number of times the current playback has stalled, since last heartbeat. */
-    stalled_count: number;
-    /** The *total* number of times the current playback has waited, since last heartbeat. */
-    waiting_count: number;
-    /** The time the playback has spent in a warning state, in ms, since last heartbeat. */
-    time_warning_ms: number;
-    /** The time the playback has spent in an errored state, in ms, since last heartbeat. */
-    time_errored_ms: number;
-    /** The time the playback has spent stalled, in ms, since last heartbeat. */
-    time_stalled_ms: number;
-    /** The time the playback has spent playing, in ms, since last heartbeat. */
-    time_playing_ms: number;
-    /** The time the playback has spent waiting, in ms, since last heartbeat. */
-    time_waiting_ms: number;
-    /** The state of autoplay of the video. */
-    autoplay_status?: "autoplay" | "none";
-    /** The time from when the metrics were added to play, in milliseconds. */
-    mount_to_play_ms?: number;
-    /** The time from when the metrics were added to the first frame, in milliseconds. */
-    mount_to_first_frame_ms?: number;
-    /** The time from the first play event to the first frame, in milliseconds. Also called TTFF. */
-    play_to_first_frame_ms?: number;
-    /** The duration of the video, in milliseconds. This is only sent for VOD. */
-    duration_ms?: number;
-    /** The offset of the live video head compared to the server time, in milliseconds. */
-    offset_ms?: number;
-    /** The timestamp of the oldest buffer event, in milliseconds. Only sent when this differs from the heartbeat timestamp. */
-    oldest_buffer_timestamp?: number;
-    /** The height of the player element, in px. */
-    player_height_px?: number;
-    /** The width of the player element, in px. */
-    player_width_px?: number;
-    /** The height of the source video, in px. */
-    video_height_px?: number;
-    /** The width of the source video, in px. */
-    video_width_px?: number;
-    /** The height of the window, in px. */
-    window_height_px?: number;
-    /** The width of the window, in px. */
-    window_width_px?: number;
+  /** The event ID. */
+  id: string;
+  /** The event type. */
+  type: "heartbeat";
+  /** The timestamp of the event, in milliseconds. */
+  timestamp: number;
+  /** The number of errors that have occurred since last heartbeat. */
+  errors: number;
+  /** The number of warnings that have occurred since last heartbeat. */
+  warnings: number;
+  /** The number of times the current playback has stalled, since last heartbeat. */
+  stalled_count: number;
+  /** The *total* number of times the current playback has waited, since last heartbeat. */
+  waiting_count: number;
+  /** The time the playback has spent in a warning state, in ms, since last heartbeat. */
+  time_warning_ms: number;
+  /** The time the playback has spent in an errored state, in ms, since last heartbeat. */
+  time_errored_ms: number;
+  /** The time the playback has spent stalled, in ms, since last heartbeat. */
+  time_stalled_ms: number;
+  /** The time the playback has spent playing, in ms, since last heartbeat. */
+  time_playing_ms: number;
+  /** The time the playback has spent waiting, in ms, since last heartbeat. */
+  time_waiting_ms: number;
+  /** The state of autoplay of the video. */
+  autoplay_status?: "autoplay" | "none";
+  /** The time from when the metrics were added to play, in milliseconds. */
+  mount_to_play_ms?: number;
+  /** The time from when the metrics were added to the first frame, in milliseconds. */
+  mount_to_first_frame_ms?: number;
+  /** The time from the first play event to the first frame, in milliseconds. Also called TTFF. */
+  play_to_first_frame_ms?: number;
+  /** The duration of the video, in milliseconds. This is only sent for VOD. */
+  duration_ms?: number;
+  /** The offset of the live video head compared to the server time, in milliseconds. */
+  offset_ms?: number;
+  /** The timestamp of the oldest buffer event, in milliseconds. Only sent when this differs from the heartbeat timestamp. */
+  oldest_buffer_timestamp?: number;
+  /** The height of the player element, in px. */
+  player_height_px?: number;
+  /** The width of the player element, in px. */
+  player_width_px?: number;
+  /** The height of the source video, in px. */
+  video_height_px?: number;
+  /** The width of the source video, in px. */
+  video_width_px?: number;
+  /** The height of the window, in px. */
+  window_height_px?: number;
+  /** The width of the window, in px. */
+  window_width_px?: number;
 };
 type ErrorEvent = {
-    /** The event ID. */
-    id: string;
-    /** The event type. */
-    type: "error";
-    /** The timestamp of the event, in milliseconds. */
-    timestamp: number;
-    /** The raw event error message. */
-    message: string;
-    /** The category of the error. */
-    category: "access-control" | "permissions" | "unknown";
+  /** The event ID. */
+  id: string;
+  /** The event type. */
+  type: "error";
+  /** The timestamp of the event, in milliseconds. */
+  timestamp: number;
+  /** The raw event error message. */
+  message: string;
+  /** The category of the error. */
+  category: "access-control" | "permissions" | "unknown";
 };
 type WarningEvent = {
-    /** The event ID. */
-    id: string;
-    /** The event type. */
-    type: "warning";
-    /** The timestamp of the event, in milliseconds. */
-    timestamp: number;
-    /** The raw event warning message. */
-    message: string;
-    /** The category of the warning. */
-    category: "offline" | "fallback";
+  /** The event ID. */
+  id: string;
+  /** The event type. */
+  type: "warning";
+  /** The timestamp of the event, in milliseconds. */
+  timestamp: number;
+  /** The raw event warning message. */
+  message: string;
+  /** The category of the warning. */
+  category: "offline" | "fallback";
 };
 type HtmlEvent = {
-    /** The event ID. */
-    id: string;
-    /** The event type. */
-    type: "play" | "pause" | "enter-fullscreen" | "exit-fullscreen" | "enter-pip" | "exit-pip" | "can-play" | "ended" | "first-frame";
-    /** The timestamp of the event, in milliseconds. */
-    timestamp: number;
+  /** The event ID. */
+  id: string;
+  /** The event type. */
+  type:
+    | "play"
+    | "pause"
+    | "enter-fullscreen"
+    | "exit-fullscreen"
+    | "enter-pip"
+    | "exit-pip"
+    | "can-play"
+    | "ended"
+    | "first-frame";
+  /** The timestamp of the event, in milliseconds. */
+  timestamp: number;
 };
 type ClipEvent = {
-    /** The event ID. */
-    id: string;
-    /** The event type. */
-    type: "clip";
-    /** The timestamp of the event, in milliseconds. */
-    timestamp: number;
-    /** The start time of the clip, in Unix ms. */
-    startTime: number;
-    /** The end time of the clip, in Unix ms. */
-    endTime: number;
+  /** The event ID. */
+  id: string;
+  /** The event type. */
+  type: "clip";
+  /** The timestamp of the event, in milliseconds. */
+  timestamp: number;
+  /** The start time of the clip, in Unix ms. */
+  startTime: number;
+  /** The end time of the clip, in Unix ms. */
+  endTime: number;
 };
 type RateChangeEvent = {
-    /** The event ID. */
-    id: string;
-    /** The event type. */
-    type: "rate";
-    /** The timestamp of the event, in milliseconds. */
-    timestamp: number;
-    /** The playback rate. */
-    payload: PlaybackRate;
+  /** The event ID. */
+  id: string;
+  /** The event type. */
+  type: "rate";
+  /** The timestamp of the event, in milliseconds. */
+  timestamp: number;
+  /** The playback rate. */
+  payload: PlaybackRate;
 };
 type SeekEvent = {
-    /** The event ID. */
-    id: string;
-    /** The event type. */
-    type: "seek";
-    /** The timestamp of the event, in milliseconds. */
-    timestamp: number;
-    /** The seek timestamp. */
-    payload: number;
+  /** The event ID. */
+  id: string;
+  /** The event type. */
+  type: "seek";
+  /** The timestamp of the event, in milliseconds. */
+  timestamp: number;
+  /** The seek timestamp. */
+  payload: number;
 };
 type VideoQualityEvent = {
-    /** The event ID. */
-    id: string;
-    /** The event type. */
-    type: "video-quality";
-    /** The timestamp of the event, in milliseconds. */
-    timestamp: number;
-    /** The video playback quality enum. */
-    payload: VideoQuality;
-};
-type PlaybackEvent = HeartbeatEvent | ErrorEvent | WarningEvent | ClipEvent | HtmlEvent | RateChangeEvent | SeekEvent | VideoQualityEvent;
+  /** The event ID. */
+  id: string;
+  /** The event type. */
+  type: "video-quality";
+  /** The timestamp of the event, in milliseconds. */
+  timestamp: number;
+  /** The video playback quality enum. */
+  payload: VideoQuality;
+};
+type PlaybackEvent =
+  | HeartbeatEvent
+  | ErrorEvent
+  | WarningEvent
+  | ClipEvent
+  | HtmlEvent
+  | RateChangeEvent
+  | SeekEvent
+  | VideoQualityEvent;
 type SessionData = {
-    session_id: string;
-    playback_id: string;
-    protocol?: Src["mime"];
-    domain: string | null;
-    path: string | null;
-    params: string | null;
-    hash: string | null;
-    source_url: string;
-    player: Src["type"];
-    version: string;
-    user_agent?: string;
-    uid?: string;
-    events: PlaybackEvent[];
-    live: boolean;
+  session_id: string;
+  playback_id: string;
+  protocol?: Src["mime"];
+  domain: string | null;
+  path: string | null;
+  params: string | null;
+  hash: string | null;
+  source_url: string;
+  player: Src["type"];
+  version: string;
+  user_agent?: string;
+  uid?: string;
+  events: PlaybackEvent[];
+  live: boolean;
 };
 /**
  * Gather playback metrics from a media store and
@@ -888,18 +974,63 @@ type SessionData = {
  * @param opts.disableProgressListener Disables the `progress` event listener, which is used to monitor when media is in a "playing" state.
  * @param opts.onPlaybackEvents A callback that is called when the player's metrics events are emitted. This can be used to integrate with other analytics providers.
  */
-declare function addMetricsToStore(store: MediaControllerStore | undefined | null, opts?: {
+declare function addMetricsToStore(
+  store: MediaControllerStore | undefined | null,
+  opts?: {
     interval?: number;
     disableProgressListener?: boolean;
     onPlaybackEvents?: (events: PlaybackEvent[]) => Promise<any> | any;
-}): {
-    destroy: () => void;
+  }
+): {
+  destroy: () => void;
 };
 
 declare const getBoundedVolume: (volume: number) => number;
-declare function calculateVideoQualityDimensions(videoQuality: VideoQuality, aspectRatio: InitialProps["aspectRatio"]): {
-    width: number | null;
-    height: number | null;
+declare function calculateVideoQualityDimensions(
+  videoQuality: VideoQuality,
+  aspectRatio: InitialProps["aspectRatio"]
+): {
+  width: number | null;
+  height: number | null;
 };
 
-export { type AccessControlParams, type AriaText, type AudioSrc, type AudioTrackSelector, type Base64Src, type ClipLength, type ClipParams, type ControlsState, type DeviceInformation, type ElementSize, type HlsSrc, type InitialProps, type LegacyMediaMetrics, LegacyMetricsStatus, LegacyPlaybackMonitor, type MediaControllerState, type MediaControllerStore, type MediaSizing, type Metadata, type ObjectFit, type PlaybackError, type PlaybackEvent, type PlaybackRate, type SessionData, type SingleAudioTrackSelector, type SingleTrackSelector, type SingleVideoTrackSelector, type Src, type VideoQuality, type VideoSrc, type VideoTrackSelector, type WebRTCSrc, addLegacyMediaMetricsToStore, addMetricsToStore, calculateVideoQualityDimensions, createControllerStore, getBoundedVolume, getMediaSourceType };
+export {
+  type AccessControlParams,
+  type AriaText,
+  type AudioSrc,
+  type AudioTrackSelector,
+  type Base64Src,
+  type ClipLength,
+  type ClipParams,
+  type ControlsState,
+  type DeviceInformation,
+  type ElementSize,
+  type HlsSrc,
+  type InitialProps,
+  type LegacyMediaMetrics,
+  LegacyMetricsStatus,
+  LegacyPlaybackMonitor,
+  type MediaControllerState,
+  type MediaControllerStore,
+  type MediaSizing,
+  type Metadata,
+  type ObjectFit,
+  type PlaybackError,
+  type PlaybackEvent,
+  type PlaybackRate,
+  type SessionData,
+  type SingleAudioTrackSelector,
+  type SingleTrackSelector,
+  type SingleVideoTrackSelector,
+  type Src,
+  type VideoQuality,
+  type VideoSrc,
+  type VideoTrackSelector,
+  type WebRTCSrc,
+  addLegacyMediaMetricsToStore,
+  addMetricsToStore,
+  calculateVideoQualityDimensions,
+  createControllerStore,
+  getBoundedVolume,
+  getMediaSourceType,
+};
diff --git a/dist/media/index.d.ts b/dist/media/index.d.ts
index 1c17bb63a984648666e2e70e80ae8901dc06266e..a4e1bb960d03da2cbf4f5c8ea6760794610d072b 100644
--- a/dist/media/index.d.ts
+++ b/dist/media/index.d.ts
@@ -276,6 +276,10 @@ type InitialProps = {
      * Set to `null` to disable the ClipTrigger.
      */
     clipLength: ClipLength | null;
+    /**
+     * If true, won't append the token to the playback URL.
+     */
+    forceNoToken?: boolean;
     /**
      * How long to cache WebRTC timeouts for faster subsequent playbacks after a timeout.
      *
diff --git a/dist/media/index.js b/dist/media/index.js
index a42189b7711af0ea8b73006858264867a659ac3a..796d2403c93878e3d32c82540b2ae43e124edb3f 100644
--- a/dist/media/index.js
+++ b/dist/media/index.js
@@ -2,7 +2,7 @@
 import {
   createJSONStorage,
   persist,
-  subscribeWithSelector
+  subscribeWithSelector,
 } from "zustand/middleware";
 import { createStore } from "zustand/vanilla";
 
@@ -10,15 +10,25 @@ import { createStore } from "zustand/vanilla";
 var STREAM_OPEN_ERROR_MESSAGE = "stream open failed";
 var STREAM_OFFLINE_ERROR_MESSAGE = "stream is offline";
 var STREAM_WAITING_FOR_DATA_ERROR_MESSAGE = "stream is waiting for data";
-var ACCESS_CONTROL_ERROR_MESSAGE = "shutting down since this session is not allowed to view this stream";
-var BFRAMES_ERROR_MESSAGE = "metadata indicates that webrtc playback contains bframes";
-var NOT_ACCEPTABLE_ERROR_MESSAGE = "response indicates unacceptable playback protocol";
+var ACCESS_CONTROL_ERROR_MESSAGE =
+  "shutting down since this session is not allowed to view this stream";
+var BFRAMES_ERROR_MESSAGE =
+  "metadata indicates that webrtc playback contains bframes";
+var NOT_ACCEPTABLE_ERROR_MESSAGE =
+  "response indicates unacceptable playback protocol";
 var PERMISSIONS_ERROR_MESSAGE = "user did not allow the permissions request";
-var isStreamOfflineError = (error) => error.message.toLowerCase().includes(STREAM_OPEN_ERROR_MESSAGE) || error.message.toLowerCase().includes(STREAM_WAITING_FOR_DATA_ERROR_MESSAGE) || error.message.toLowerCase().includes(STREAM_OFFLINE_ERROR_MESSAGE);
-var isAccessControlError = (error) => error.message.toLowerCase().includes(ACCESS_CONTROL_ERROR_MESSAGE);
-var isBframesError = (error) => error.message.toLowerCase().includes(BFRAMES_ERROR_MESSAGE);
-var isNotAcceptableError = (error) => error.message.toLowerCase().includes(NOT_ACCEPTABLE_ERROR_MESSAGE);
-var isPermissionsError = (error) => error.message.toLowerCase().includes(PERMISSIONS_ERROR_MESSAGE);
+var isStreamOfflineError = (error) =>
+  error.message.toLowerCase().includes(STREAM_OPEN_ERROR_MESSAGE) ||
+  error.message.toLowerCase().includes(STREAM_WAITING_FOR_DATA_ERROR_MESSAGE) ||
+  error.message.toLowerCase().includes(STREAM_OFFLINE_ERROR_MESSAGE);
+var isAccessControlError = (error) =>
+  error.message.toLowerCase().includes(ACCESS_CONTROL_ERROR_MESSAGE);
+var isBframesError = (error) =>
+  error.message.toLowerCase().includes(BFRAMES_ERROR_MESSAGE);
+var isNotAcceptableError = (error) =>
+  error.message.toLowerCase().includes(NOT_ACCEPTABLE_ERROR_MESSAGE);
+var isPermissionsError = (error) =>
+  error.message.toLowerCase().includes(PERMISSIONS_ERROR_MESSAGE);
 
 // src/media/utils.ts
 import { customAlphabet } from "nanoid";
@@ -27,7 +37,7 @@ import { customAlphabet } from "nanoid";
 var getMetricsReportingPOSTUrl = async (opts) => {
   const resolvedReportingUrl = await getMetricsReportingUrl({
     playbackUrl: opts.playbackUrl,
-    path: "/analytics/log"
+    path: "/analytics/log",
   });
   if (!resolvedReportingUrl) {
     return null;
@@ -40,7 +50,7 @@ var getMetricsReportingWebsocketUrl = async (opts) => {
   }
   const resolvedReportingUrl = await getMetricsReportingUrl({
     playbackUrl: opts.playbackUrl,
-    path: `/json_video+${opts.playbackId}.js`
+    path: `/json_video+${opts.playbackId}.js`,
   });
   if (!resolvedReportingUrl) {
     return null;
@@ -52,10 +62,7 @@ var getMetricsReportingWebsocketUrl = async (opts) => {
   return resolvedReportingUrl?.toString?.() ?? null;
 };
 var LP_DOMAINS = ["livepeer", "livepeercdn", "lp-playback"];
-var getMetricsReportingUrl = async ({
-  playbackUrl,
-  path
-}) => {
+var getMetricsReportingUrl = async ({ playbackUrl, path }) => {
   try {
     const parsedPlaybackUrl = new URL(playbackUrl);
     const splitHost = parsedPlaybackUrl.host.split(".");
@@ -63,7 +70,16 @@ var getMetricsReportingUrl = async ({
       splitHost?.[splitHost.length - 2] ?? ""
     );
     const tld = splitHost?.[splitHost?.length - 1] ?? null;
-    const tldMapped = tld === "com" ? "studio" : tld === "studio" ? "studio" : tld === "fun" ? "fun:20443" : tld === "monster" ? "monster" : null;
+    const tldMapped =
+      tld === "com"
+        ? "studio"
+        : tld === "studio"
+        ? "studio"
+        : tld === "fun"
+        ? "fun:20443"
+        : tld === "monster"
+        ? "monster"
+        : null;
     if (includesDomain && tldMapped) {
       const isCatalystPlayback = parsedPlaybackUrl.host.includes("catalyst");
       try {
@@ -74,7 +90,9 @@ var getMetricsReportingUrl = async ({
           await response.text();
           return response?.url ?? null;
         };
-        const finalUrl = isCatalystPlayback ? `https://${parsedPlaybackUrl.host}${path}` : await getRedirectedUrl();
+        const finalUrl = isCatalystPlayback
+          ? `https://${parsedPlaybackUrl.host}${path}`
+          : await getRedirectedUrl();
         const url = finalUrl ? new URL(finalUrl) : null;
         return url ?? null;
       } catch (error) {
@@ -98,7 +116,12 @@ var getPlaybackIdFromSourceUrl = (sourceUrl) => {
   const includesWebRtcUrl = parts.includes(WEBRTC_URL_PART_VALUE);
   const includesFlvUrl = parts.includes(FLV_URL_PART_VALUE);
   const includesRecording = parts.includes(RECORDING_URL_PART_VALUE);
-  const playbackId = includesWebRtcUrl || includesFlvUrl ? parts?.[(parts?.length ?? 0) - 1] : includesRecording || includesAssetUrl ? parts?.[(parts?.length ?? 0) - 2] ?? null : null;
+  const playbackId =
+    includesWebRtcUrl || includesFlvUrl
+      ? parts?.[(parts?.length ?? 0) - 1]
+      : includesRecording || includesAssetUrl
+      ? parts?.[(parts?.length ?? 0) - 2] ?? null
+      : null;
   if (playbackId?.includes("+")) {
     const split = playbackId.split("+")?.[1];
     if (split) {
@@ -202,11 +225,12 @@ var mime = {
   "video/x-ms-wvx": ["wvx"],
   "video/x-msvideo": ["avi"],
   "video/x-sgi-movie": ["movie"],
-  "video/x-smv": ["smv"]
+  "video/x-smv": ["smv"],
 };
 
 // src/media/src.ts
-var audioExtensions = /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
+var audioExtensions =
+  /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
 var base64String = /data:video/i;
 var hlsExtensions = /\.(m3u8)($|\?)/i;
 var flvExtensions = /\/(flv)\//i;
@@ -223,77 +247,94 @@ var getMediaSourceType = (src, opts) => {
   const base64Mime = sourceTest.match(mimeFromBase64Pattern);
   const resolvedWidth = opts?.sizing?.width ?? null;
   const resolvedHeight = opts?.sizing?.height ?? null;
-  return webrtcExtensions.test(sourceTest) ? {
-    type: "webrtc",
-    src,
-    mime: "video/h264",
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : hlsExtensions.test(sourceTest) ? {
-    type: "hls",
-    src,
-    mime: getMimeType(hlsExtensions.exec(sourceTest)?.[1] ?? ""),
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : videoExtensions.test(sourceTest) ? {
-    type: "video",
-    src,
-    mime: getMimeType(videoExtensions.exec(sourceTest)?.[1] ?? ""),
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : audioExtensions.test(sourceTest) ? {
-    type: "audio",
-    src,
-    mime: getMimeType(audioExtensions.exec(sourceTest)?.[1] ?? ""),
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : base64String.test(sourceTest) ? {
-    type: "video",
-    src,
-    mime: base64Mime ? base64Mime[1] : "video/mp4",
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : imageExtensions.test(sourceTest) ? {
-    type: "image",
-    src,
-    mime: getMimeType(
-      imageExtensions.exec(sourceTest)?.[1] ?? ""
-    ),
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : vttExtensions.test(sourceTest) ? {
-    type: "vtt",
-    src,
-    mime: getMimeType(
-      vttExtensions.exec(sourceTest)?.[1] ?? ""
-    ),
-    width: null,
-    height: null
-  } : flvExtensions.test(sourceTest) ? {
-    type: "video",
-    src,
-    mime: "video/x-flv",
-    width: resolvedWidth,
-    height: resolvedHeight
-  } : null;
+  return webrtcExtensions.test(sourceTest)
+    ? {
+        type: "webrtc",
+        src,
+        mime: "video/h264",
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : hlsExtensions.test(sourceTest)
+    ? {
+        type: "hls",
+        src,
+        mime: getMimeType(hlsExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : videoExtensions.test(sourceTest)
+    ? {
+        type: "video",
+        src,
+        mime: getMimeType(videoExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : audioExtensions.test(sourceTest)
+    ? {
+        type: "audio",
+        src,
+        mime: getMimeType(audioExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : base64String.test(sourceTest)
+    ? {
+        type: "video",
+        src,
+        mime: base64Mime ? base64Mime[1] : "video/mp4",
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : imageExtensions.test(sourceTest)
+    ? {
+        type: "image",
+        src,
+        mime: getMimeType(imageExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : vttExtensions.test(sourceTest)
+    ? {
+        type: "vtt",
+        src,
+        mime: getMimeType(vttExtensions.exec(sourceTest)?.[1] ?? ""),
+        width: null,
+        height: null,
+      }
+    : flvExtensions.test(sourceTest)
+    ? {
+        type: "video",
+        src,
+        mime: "video/x-flv",
+        width: resolvedWidth,
+        height: resolvedHeight,
+      }
+    : null;
 };
 
 // src/media/utils.ts
 var DEFAULT_ASPECT_RATIO = 16 / 9;
-var getFilteredNaN = (value) => value && !Number.isNaN(value) && Number.isFinite(value) ? value : 0;
-var getBoundedSeek = (seek, duration) => Math.min(
-  Math.max(0, getFilteredNaN(seek)),
-  // seek to near the end
-  getFilteredNaN(duration) ? getFilteredNaN(duration) - 0.01 : 0
-);
+var getFilteredNaN = (value) =>
+  value && !Number.isNaN(value) && Number.isFinite(value) ? value : 0;
+var getBoundedSeek = (seek, duration) =>
+  Math.min(
+    Math.max(0, getFilteredNaN(seek)),
+    // seek to near the end
+    getFilteredNaN(duration) ? getFilteredNaN(duration) - 0.01 : 0
+  );
 var getBoundedRate = (rate) => {
   if (typeof rate === "number") {
     return Math.min(Math.max(0, getFilteredNaN(rate)), 20);
   }
   const match = String(rate).match(/(\d+(\.\d+)?)/);
-  return match ? Math.min(Math.max(0, getFilteredNaN(Number.parseFloat(match[0]))), 20) : 1;
+  return match
+    ? Math.min(Math.max(0, getFilteredNaN(Number.parseFloat(match[0]))), 20)
+    : 1;
 };
-var getBoundedVolume = (volume) => Math.min(Math.max(0, getFilteredNaN(volume)), 1);
+var getBoundedVolume = (volume) =>
+  Math.min(Math.max(0, getFilteredNaN(volume)), 1);
 var nanoid = customAlphabet(
   "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
   22
@@ -301,38 +342,42 @@ var nanoid = customAlphabet(
 var generateRandomToken = () => {
   return nanoid();
 };
-var getClipParams = ({
-  requestedTime,
-  clipLength,
-  playbackOffsetMs
-}) => {
+var getClipParams = ({ requestedTime, clipLength, playbackOffsetMs }) => {
   const currentTime = requestedTime ?? Date.now();
   const estimatedServerClipTime = currentTime - (playbackOffsetMs ?? 0);
   const startTime = estimatedServerClipTime - clipLength * 1e3;
   const endTime = estimatedServerClipTime;
   return {
     startTime,
-    endTime
+    endTime,
   };
 };
-var getProgressAria = ({
-  progress,
-  duration,
-  live
-}) => {
+var getProgressAria = ({ progress, duration, live }) => {
   const progressParsed = getHoursMinutesSeconds(progress ?? null);
   const durationParsed = getHoursMinutesSeconds(duration ?? null);
-  const progressText = `${progressParsed.hours ? `${progressParsed.hours} hours ` : ""}${progressParsed.minutes ? `${progressParsed.minutes} minutes ` : ""}${progressParsed.seconds ? `${progressParsed.seconds} seconds` : ""}`;
-  const durationText = `${durationParsed.hours ? `${durationParsed.hours} hours ` : ""}${durationParsed.minutes ? `${durationParsed.minutes} minutes ` : ""}${durationParsed.seconds ? `${durationParsed.seconds} seconds` : ""}`;
-  const progressDisplay = live ? `Live ${progressText}` : `${progressText} of ${durationText}`;
+  const progressText = `${
+    progressParsed.hours ? `${progressParsed.hours} hours ` : ""
+  }${progressParsed.minutes ? `${progressParsed.minutes} minutes ` : ""}${
+    progressParsed.seconds ? `${progressParsed.seconds} seconds` : ""
+  }`;
+  const durationText = `${
+    durationParsed.hours ? `${durationParsed.hours} hours ` : ""
+  }${durationParsed.minutes ? `${durationParsed.minutes} minutes ` : ""}${
+    durationParsed.seconds ? `${durationParsed.seconds} seconds` : ""
+  }`;
+  const progressDisplay = live
+    ? `Live ${progressText}`
+    : `${progressText} of ${durationText}`;
   const formattedTimeDisplay = getFormattedHoursMinutesSeconds(
     progress ?? null
   );
   const formattedDuration = getFormattedHoursMinutesSeconds(duration ?? null);
-  const formattedTime = live ? formattedTimeDisplay : `${formattedTimeDisplay} / ${formattedDuration}`;
+  const formattedTime = live
+    ? formattedTimeDisplay
+    : `${formattedTimeDisplay} / ${formattedDuration}`;
   return {
     progress: progressDisplay,
-    time: formattedTime
+    time: formattedTime,
   };
 };
 var sortSources = ({
@@ -341,7 +386,7 @@ var sortSources = ({
   screenWidth,
   aspectRatio,
   lowLatency,
-  hasRecentWebRTCTimeout
+  hasRecentWebRTCTimeout,
 }) => {
   if (!src) {
     return null;
@@ -350,40 +395,63 @@ var sortSources = ({
     const mediaSourceType = getMediaSourceType(src);
     return mediaSourceType ? [mediaSourceType] : null;
   }
-  const filteredVideoSources = src.filter(
-    (s) => s.type === "audio" || s.type === "hls" || s.type === "webrtc" || s.type === "video"
-  ).filter((s) => {
-    if (s.type === "hls" && lowLatency === "force") {
-      return false;
-    }
-    if (s.type === "webrtc" && (lowLatency === false || hasRecentWebRTCTimeout)) {
-      return false;
-    }
-    return true;
-  });
+  const filteredVideoSources = src
+    .filter(
+      (s) =>
+        s.type === "audio" ||
+        s.type === "hls" ||
+        s.type === "webrtc" ||
+        s.type === "video"
+    )
+    .filter((s) => {
+      if (s.type === "hls" && lowLatency === "force") {
+        return false;
+      }
+      if (
+        s.type === "webrtc" &&
+        (lowLatency === false || hasRecentWebRTCTimeout)
+      ) {
+        return false;
+      }
+      return true;
+    });
   const videoQualityDimensions = calculateVideoQualityDimensions(
     videoQuality,
     aspectRatio
   );
   const targetWidth = videoQualityDimensions?.width ?? screenWidth ?? 1280;
-  const sourceWithParentDelta = filteredVideoSources?.map(
-    (s) => s.type === "hls" || s.type === "webrtc" ? { ...s, parentWidthDelta: null } : {
-      ...s,
-      parentWidthDelta: (
-        // first we check if the URL contains the video quality selector
-        videoQuality && videoQuality !== "auto" && s?.src?.includes(videoQuality) ? 0 : (
-          // otherwise use the width of the src
-          s?.width ? Math.abs(targetWidth - s.width) : (
-            // otherwise guess the width of the src based on the url
-            s?.src.includes("static360p") || s?.src.includes("low-bitrate") ? Math.abs(targetWidth - 480) : s?.src.includes("static720p") ? Math.abs(targetWidth - 1280) : s?.src.includes("static1080p") ? Math.abs(targetWidth - 1920) : s?.src.includes("static2160p") ? Math.abs(targetWidth - 3840) : null
-          )
-        )
-      )
-    }
-  ) ?? [];
+  const sourceWithParentDelta =
+    filteredVideoSources?.map((s) =>
+      s.type === "hls" || s.type === "webrtc"
+        ? { ...s, parentWidthDelta: null }
+        : {
+            ...s,
+            parentWidthDelta:
+              // first we check if the URL contains the video quality selector
+              videoQuality &&
+              videoQuality !== "auto" &&
+              s?.src?.includes(videoQuality)
+                ? 0
+                : // otherwise use the width of the src
+                s?.width
+                ? Math.abs(targetWidth - s.width)
+                : // otherwise guess the width of the src based on the url
+                s?.src.includes("static360p") || s?.src.includes("low-bitrate")
+                ? Math.abs(targetWidth - 480)
+                : s?.src.includes("static720p")
+                ? Math.abs(targetWidth - 1280)
+                : s?.src.includes("static1080p")
+                ? Math.abs(targetWidth - 1920)
+                : s?.src.includes("static2160p")
+                ? Math.abs(targetWidth - 3840)
+                : null,
+          }
+    ) ?? [];
   const sortedSources = sourceWithParentDelta.sort((a, b) => {
     if (a.type === "video" && b.type === "video") {
-      return b?.parentWidthDelta !== null && a?.parentWidthDelta !== null ? a.parentWidthDelta - b.parentWidthDelta : 1;
+      return b?.parentWidthDelta !== null && a?.parentWidthDelta !== null
+        ? a.parentWidthDelta - b.parentWidthDelta
+        : 1;
     }
     if (a.type === "video" && (b.type === "hls" || b.type === "webrtc")) {
       return -1;
@@ -403,14 +471,15 @@ var parseCurrentSourceAndPlaybackId = ({
   jwt,
   sessionToken,
   source,
-  videoQuality
+  videoQuality,
+  forceNoToken,
 }) => {
   if (!source) {
     return null;
   }
   const playbackId = getPlaybackIdFromSourceUrl(source.src);
   const url = new URL(source.src);
-  if (sessionToken) {
+  if (sessionToken && !forceNoToken) {
     url.searchParams.append("tkn", sessionToken);
   }
   if (source.type !== "webrtc" && source.type !== "hls") {
@@ -434,15 +503,18 @@ var parseCurrentSourceAndPlaybackId = ({
   }
   const newSrc = {
     ...source,
-    src: url.toString()
+    src: url.toString(),
   };
-  const videoSourceIfHlsUnsupported = newSrc?.type === "hls" && !isHlsSupported ? {
-    ...newSrc,
-    type: "video"
-  } : newSrc;
+  const videoSourceIfHlsUnsupported =
+    newSrc?.type === "hls" && !isHlsSupported
+      ? {
+          ...newSrc,
+          type: "video",
+        }
+      : newSrc;
   return {
     currentSource: videoSourceIfHlsUnsupported,
-    playbackId
+    playbackId,
   };
 };
 var getNewSource = ({
@@ -456,7 +528,8 @@ var getNewSource = ({
   sessionToken,
   src,
   videoQuality,
-  hasRecentWebRTCTimeout
+  hasRecentWebRTCTimeout,
+  forceNoToken,
 }) => {
   const sortedSources = sortSources({
     src,
@@ -464,7 +537,7 @@ var getNewSource = ({
     videoQuality,
     aspectRatio: aspectRatio ?? DEFAULT_ASPECT_RATIO,
     lowLatency,
-    hasRecentWebRTCTimeout
+    hasRecentWebRTCTimeout,
   });
   const parsedSource = parseCurrentSourceAndPlaybackId({
     accessKey: accessKey ?? null,
@@ -474,12 +547,13 @@ var getNewSource = ({
     playbackRate,
     sessionToken,
     source: sortedSources?.[0] ?? null,
-    videoQuality
+    videoQuality,
+    forceNoToken,
   });
   return {
     currentSource: parsedSource?.currentSource ?? null,
     playbackId: parsedSource?.playbackId ?? null,
-    sortedSources
+    sortedSources,
   };
 };
 var getVideoTrackSelectorForQuality = (videoQuality, aspectRatio) => {
@@ -496,46 +570,75 @@ var getVideoTrackSelectorForQuality = (videoQuality, aspectRatio) => {
   return null;
 };
 function calculateVideoQualityDimensions(videoQuality, aspectRatio) {
-  const height = videoQuality === "1080p" ? 1080 : videoQuality === "720p" ? 720 : videoQuality === "480p" ? 480 : videoQuality === "360p" ? 360 : videoQuality === "240p" ? 240 : videoQuality === "144p" ? 144 : null;
+  const height =
+    videoQuality === "1080p"
+      ? 1080
+      : videoQuality === "720p"
+      ? 720
+      : videoQuality === "480p"
+      ? 480
+      : videoQuality === "360p"
+      ? 360
+      : videoQuality === "240p"
+      ? 240
+      : videoQuality === "144p"
+      ? 144
+      : null;
   return {
-    width: height !== null ? Math.round(height * (aspectRatio ?? 16 / 9)) : null,
-    height
+    width:
+      height !== null ? Math.round(height * (aspectRatio ?? 16 / 9)) : null,
+    height,
   };
 }
 var getFormattedHoursMinutesSeconds = (valueInSeconds) => {
   const hoursMinutesSeconds = getHoursMinutesSeconds(valueInSeconds);
-  if (hoursMinutesSeconds.seconds || hoursMinutesSeconds.minutes || hoursMinutesSeconds.hours) {
+  if (
+    hoursMinutesSeconds.seconds ||
+    hoursMinutesSeconds.minutes ||
+    hoursMinutesSeconds.hours
+  ) {
     if (hoursMinutesSeconds.hours > 0) {
-      return `${hoursMinutesSeconds.hours}:${hoursMinutesSeconds.minutes.toString().padStart(2, "0")}:${hoursMinutesSeconds.seconds < 10 ? "0" : ""}${hoursMinutesSeconds.seconds}`;
+      return `${hoursMinutesSeconds.hours}:${hoursMinutesSeconds.minutes
+        .toString()
+        .padStart(2, "0")}:${hoursMinutesSeconds.seconds < 10 ? "0" : ""}${
+        hoursMinutesSeconds.seconds
+      }`;
     }
-    return `${hoursMinutesSeconds.minutes}:${hoursMinutesSeconds.seconds.toString().padStart(2, "0")}`;
+    return `${hoursMinutesSeconds.minutes}:${hoursMinutesSeconds.seconds
+      .toString()
+      .padStart(2, "0")}`;
   }
   return "0:00";
 };
 var getHoursMinutesSeconds = (valueInSeconds) => {
-  if (valueInSeconds !== void 0 && valueInSeconds !== null && !Number.isNaN(valueInSeconds) && Number.isFinite(valueInSeconds)) {
+  if (
+    valueInSeconds !== void 0 &&
+    valueInSeconds !== null &&
+    !Number.isNaN(valueInSeconds) &&
+    Number.isFinite(valueInSeconds)
+  ) {
     const roundedValue = Math.round(valueInSeconds);
     const hours = Math.floor(roundedValue / 3600);
     const seconds = Math.floor(roundedValue % 60);
     if (hours > 0) {
-      const minutes2 = Math.floor(roundedValue % 3600 / 60);
+      const minutes2 = Math.floor((roundedValue % 3600) / 60);
       return {
         hours,
         minutes: minutes2,
-        seconds
+        seconds,
       };
     }
     const minutes = Math.floor(roundedValue / 60);
     return {
       hours: 0,
       minutes,
-      seconds
+      seconds,
     };
   }
   return {
     hours: 0,
     minutes: 0,
-    seconds: 0
+    seconds: 0,
   };
 };
 
@@ -553,7 +656,7 @@ var createControllerStore = ({
   storage,
   src,
   initialProps,
-  playbackId
+  playbackId,
 }) => {
   const initialPlaybackRate = initialProps?.playbackRate ?? 1;
   const initialVolume = getBoundedVolume(
@@ -561,7 +664,8 @@ var createControllerStore = ({
   );
   const initialVideoQuality = initialProps.videoQuality ?? "auto";
   const sessionToken = generateRandomToken();
-  const thumbnailSrc = typeof src === "string" ? null : src?.find?.((s) => s.type === "image");
+  const thumbnailSrc =
+    typeof src === "string" ? null : src?.find?.((s) => s.type === "image");
   const lowLatency = initialProps.lowLatency ?? true;
   const parsedInputSource = getNewSource({
     accessKey: initialProps?.accessKey,
@@ -576,7 +680,8 @@ var createControllerStore = ({
     videoQuality: initialVideoQuality,
     hasRecentWebRTCTimeout: getHasRecentWebRTCTimeout(
       initialProps.cacheWebRTCFailureMs
-    )
+    ),
+    forceNoToken: initialProps?.forceNoToken,
   });
   const initialControls = {
     hlsConfig: null,
@@ -597,7 +702,7 @@ var createControllerStore = ({
     sessionToken,
     size: null,
     thumbnail: thumbnailSrc ?? null,
-    volume: initialVolume
+    volume: initialVolume,
   };
   const store = createStore(
     subscribeWithSelector(
@@ -648,10 +753,12 @@ var createControllerStore = ({
             fullscreen: "Full screen (f)",
             pictureInPicture: "Mini player (i)",
             playPause: "Play (k)",
-            clip: initialProps.clipLength ? `Clip last ${Number(initialProps.clipLength).toFixed(
-              0
-            )} seconds (x)` : null,
-            time: "0:00"
+            clip: initialProps.clipLength
+              ? `Clip last ${Number(initialProps.clipLength).toFixed(
+                  0
+                )} seconds (x)`
+              : null,
+            time: "0:00",
           },
           __initialProps: {
             accessKey: initialProps.accessKey ?? null,
@@ -660,6 +767,7 @@ var createControllerStore = ({
             backoff: Math.max(initialProps.backoff ?? 500, 100),
             backoffMax: Math.max(initialProps.backoffMax ?? 3e4, 1e4),
             clipLength: initialProps.clipLength ?? null,
+            forceNoToken: initialProps?.forceNoToken ?? false,
             cacheWebRTCFailureMs: initialProps.cacheWebRTCFailureMs ?? null,
             hotkeys: initialProps?.hotkeys ?? true,
             jwt: initialProps.jwt ?? null,
@@ -672,93 +780,105 @@ var createControllerStore = ({
             timeout: initialProps.timeout ?? 1e4,
             videoQuality: initialVideoQuality,
             viewerId: initialProps.viewerId ?? null,
-            volume: initialVolume ?? null
+            volume: initialVolume ?? null,
           },
           __device: device,
           __controls: initialControls,
           __metadata: null,
           __controlsFunctions: {
-            setMounted: () => set(() => ({
-              mounted: true
-            })),
-            setPoster: (poster) => set(() => ({
-              poster
-            })),
-            setMetricsReportingUrl: (metricsReportingUrl) => set(() => ({
-              metricsReportingUrl
-            })),
+            setMounted: () =>
+              set(() => ({
+                mounted: true,
+              })),
+            setPoster: (poster) =>
+              set(() => ({
+                poster,
+              })),
+            setMetricsReportingUrl: (metricsReportingUrl) =>
+              set(() => ({
+                metricsReportingUrl,
+              })),
             onWebRTCTimeout: () => {
               webrtcTimeoutLastTime = Date.now();
             },
-            setAutohide: (autohide) => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                autohide
-              }
-            })),
-            setHlsConfig: (hlsConfig) => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                hlsConfig
-              }
-            })),
-            setHidden: (hidden) => set(({ playing }) => ({
-              hidden: playing ? hidden : false
-            })),
-            updateLastInteraction: () => set(({ __controls }) => ({
-              __controls: { ...__controls, lastInteraction: Date.now() }
-            })),
-            updatePlaybackOffsetMs: (offset) => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                playbackOffsetMs: offset
-              }
-            })),
-            onCanPlay: () => set(() => ({
-              canPlay: true,
-              loading: false
-            })),
-            onPlay: () => set(({ aria, __controls, __controlsFunctions }) => {
-              __controlsFunctions.onError(null);
-              const title = "Pause (k)";
-              return {
-                playing: true,
-                hasPlayed: true,
-                error: null,
-                errorCount: 0,
-                stalled: false,
-                waiting: false,
-                ended: false,
+            setAutohide: (autohide) =>
+              set(({ __controls }) => ({
                 __controls: {
                   ...__controls,
-                  playLastTime: Date.now()
+                  autohide,
                 },
-                aria: {
-                  ...aria,
-                  playPause: title
-                }
-              };
-            }),
-            onPause: () => set(({ aria, __controls }) => {
-              const title = "Play (k)";
-              return {
-                playing: false,
-                hidden: false,
-                stalled: false,
-                waiting: false,
-                ended: false,
-                aria: {
-                  ...aria,
-                  playPause: title
+              })),
+            setHlsConfig: (hlsConfig) =>
+              set(({ __controls }) => ({
+                __controls: {
+                  ...__controls,
+                  hlsConfig,
                 },
+              })),
+            setHidden: (hidden) =>
+              set(({ playing }) => ({
+                hidden: playing ? hidden : false,
+              })),
+            updateLastInteraction: () =>
+              set(({ __controls }) => ({
+                __controls: { ...__controls, lastInteraction: Date.now() },
+              })),
+            updatePlaybackOffsetMs: (offset) =>
+              set(({ __controls }) => ({
                 __controls: {
                   ...__controls,
-                  pauseLastTime: Date.now()
-                }
-              };
-            }),
+                  playbackOffsetMs: offset,
+                },
+              })),
+            onCanPlay: () =>
+              set(() => ({
+                canPlay: true,
+                loading: false,
+              })),
+            onPlay: () =>
+              set(({ aria, __controls, __controlsFunctions }) => {
+                __controlsFunctions.onError(null);
+                const title = "Pause (k)";
+                return {
+                  playing: true,
+                  hasPlayed: true,
+                  error: null,
+                  errorCount: 0,
+                  stalled: false,
+                  waiting: false,
+                  ended: false,
+                  __controls: {
+                    ...__controls,
+                    playLastTime: Date.now(),
+                  },
+                  aria: {
+                    ...aria,
+                    playPause: title,
+                  },
+                };
+              }),
+            onPause: () =>
+              set(({ aria, __controls }) => {
+                const title = "Play (k)";
+                return {
+                  playing: false,
+                  hidden: false,
+                  stalled: false,
+                  waiting: false,
+                  ended: false,
+                  aria: {
+                    ...aria,
+                    playPause: title,
+                  },
+                  __controls: {
+                    ...__controls,
+                    pauseLastTime: Date.now(),
+                  },
+                };
+              }),
             togglePlay: (force) => {
-              const { hidden, __device, __controlsFunctions } = store.getState();
+              const { hidden, __device, __controlsFunctions } =
+                store.getState();
               if (!force && hidden && __device.isMobile) {
                 __controlsFunctions.setHidden(false);
               } else {
@@ -766,288 +886,358 @@ var createControllerStore = ({
                   __controls: {
                     ...__controls,
                     requestedPlayPauseLastTime: Date.now(),
-                    lastInteraction: Date.now()
-                  }
+                    lastInteraction: Date.now(),
+                  },
                 }));
               }
             },
-            onProgress: (time) => set(({ aria, progress, duration, live }) => {
-              const progressAria = getProgressAria({
-                progress,
-                duration,
-                live
-              });
-              const playPauseTitle = "Pause (k)";
-              return {
-                aria: {
-                  ...aria,
-                  progress: progressAria.progress,
-                  time: progressAria.time,
-                  playPause: playPauseTitle
-                },
-                progress: getFilteredNaN(time),
-                waiting: false,
-                stalled: false,
-                ended: false
-              };
-            }),
-            requestSeek: (time) => set(({ duration, __controls }) => ({
-              __controls: {
-                ...__controls,
-                requestedRangeToSeekTo: getBoundedSeek(time, duration)
-              },
-              progress: getBoundedSeek(time, duration)
-            })),
-            onDurationChange: (duration) => set(({ live }) => ({
-              duration,
-              live: duration === Number.POSITIVE_INFINITY ? true : live
-            })),
-            setWebsocketMetadata: (metadata) => set(() => ({ __metadata: metadata })),
-            updateBuffered: (buffered) => set(({ duration }) => {
-              const durationFiltered = getFilteredNaN(duration);
-              const percent = durationFiltered > 0 && buffered > 0 ? buffered / durationFiltered * 100 : 0;
-              return {
-                buffered,
-                bufferedPercent: Number(percent.toFixed(2))
-              };
-            }),
-            setVideoQuality: (videoQuality) => set(({ __initialProps, __controls, playbackRate, __device }) => {
-              const parsedSourceNew = getNewSource({
-                accessKey: __initialProps?.accessKey,
-                aspectRatio: __initialProps.aspectRatio,
-                isHlsSupported: __device.isHlsSupported,
-                jwt: __initialProps?.jwt,
-                lowLatency: __initialProps.lowLatency,
-                playbackRate,
-                screenWidth: device.screenWidth,
-                sessionToken: __controls.sessionToken,
-                src,
-                videoQuality,
-                hasRecentWebRTCTimeout: getHasRecentWebRTCTimeout(
-                  __initialProps.cacheWebRTCFailureMs
-                )
-              });
-              return {
-                sortedSources: parsedSourceNew.sortedSources,
-                videoQuality,
-                currentSource: parsedSourceNew.currentSource,
-                __controls: {
-                  ...__controls,
-                  playbackId: playbackId ?? parsedSourceNew.playbackId
-                }
-              };
-            }),
-            setPlaybackRate: (rate) => set(() => ({
-              playbackRate: getBoundedRate(rate ?? 1)
-            })),
-            requestSeekDiff: (difference) => set(({ progress, duration, __controls }) => ({
-              __controls: {
-                ...__controls,
-                requestedRangeToSeekTo: getBoundedSeek(
-                  getFilteredNaN(progress) + difference / 1e3,
-                  duration
-                )
-              }
-            })),
-            requestSeekBack: (difference = DEFAULT_SEEK_TIME) => get().__controlsFunctions.requestSeekDiff(-difference),
-            requestSeekForward: (difference = DEFAULT_SEEK_TIME) => get().__controlsFunctions.requestSeekDiff(difference),
-            onFinalUrl: (currentUrl) => set(() => ({ currentUrl })),
-            requestMeasure: () => set(({ __controls }) => {
-              return {
+            onProgress: (time) =>
+              set(({ aria, progress, duration, live }) => {
+                const progressAria = getProgressAria({
+                  progress,
+                  duration,
+                  live,
+                });
+                const playPauseTitle = "Pause (k)";
+                return {
+                  aria: {
+                    ...aria,
+                    progress: progressAria.progress,
+                    time: progressAria.time,
+                    playPause: playPauseTitle,
+                  },
+                  progress: getFilteredNaN(time),
+                  waiting: false,
+                  stalled: false,
+                  ended: false,
+                };
+              }),
+            requestSeek: (time) =>
+              set(({ duration, __controls }) => ({
                 __controls: {
                   ...__controls,
-                  requestedMeasureLastTime: Date.now()
-                }
-              };
-            }),
-            setSize: (size) => set(({ __controls }) => {
-              return {
+                  requestedRangeToSeekTo: getBoundedSeek(time, duration),
+                },
+                progress: getBoundedSeek(time, duration),
+              })),
+            onDurationChange: (duration) =>
+              set(({ live }) => ({
+                duration,
+                live: duration === Number.POSITIVE_INFINITY ? true : live,
+              })),
+            setWebsocketMetadata: (metadata) =>
+              set(() => ({ __metadata: metadata })),
+            updateBuffered: (buffered) =>
+              set(({ duration }) => {
+                const durationFiltered = getFilteredNaN(duration);
+                const percent =
+                  durationFiltered > 0 && buffered > 0
+                    ? (buffered / durationFiltered) * 100
+                    : 0;
+                return {
+                  buffered,
+                  bufferedPercent: Number(percent.toFixed(2)),
+                };
+              }),
+            setVideoQuality: (videoQuality) =>
+              set(({ __initialProps, __controls, playbackRate, __device }) => {
+                const parsedSourceNew = getNewSource({
+                  accessKey: __initialProps?.accessKey,
+                  aspectRatio: __initialProps.aspectRatio,
+                  isHlsSupported: __device.isHlsSupported,
+                  jwt: __initialProps?.jwt,
+                  lowLatency: __initialProps.lowLatency,
+                  playbackRate,
+                  screenWidth: device.screenWidth,
+                  sessionToken: __controls.sessionToken,
+                  src,
+                  videoQuality,
+                  hasRecentWebRTCTimeout: getHasRecentWebRTCTimeout(
+                    __initialProps.cacheWebRTCFailureMs
+                  ),
+                  forceNoToken: __initialProps?.forceNoToken,
+                });
+                return {
+                  sortedSources: parsedSourceNew.sortedSources,
+                  videoQuality,
+                  currentSource: parsedSourceNew.currentSource,
+                  __controls: {
+                    ...__controls,
+                    playbackId: playbackId ?? parsedSourceNew.playbackId,
+                  },
+                };
+              }),
+            setPlaybackRate: (rate) =>
+              set(() => ({
+                playbackRate: getBoundedRate(rate ?? 1),
+              })),
+            requestSeekDiff: (difference) =>
+              set(({ progress, duration, __controls }) => ({
                 __controls: {
                   ...__controls,
-                  size: {
-                    ...__controls.size,
-                    ...size
-                  }
-                }
-              };
-            }),
+                  requestedRangeToSeekTo: getBoundedSeek(
+                    getFilteredNaN(progress) + difference / 1e3,
+                    duration
+                  ),
+                },
+              })),
+            requestSeekBack: (difference = DEFAULT_SEEK_TIME) =>
+              get().__controlsFunctions.requestSeekDiff(-difference),
+            requestSeekForward: (difference = DEFAULT_SEEK_TIME) =>
+              get().__controlsFunctions.requestSeekDiff(difference),
+            onFinalUrl: (currentUrl) => set(() => ({ currentUrl })),
+            requestMeasure: () =>
+              set(({ __controls }) => {
+                return {
+                  __controls: {
+                    ...__controls,
+                    requestedMeasureLastTime: Date.now(),
+                  },
+                };
+              }),
+            setSize: (size) =>
+              set(({ __controls }) => {
+                return {
+                  __controls: {
+                    ...__controls,
+                    size: {
+                      ...__controls.size,
+                      ...size,
+                    },
+                  },
+                };
+              }),
             onWaiting: () => set(() => ({ waiting: true })),
             onStalled: () => set(() => ({ stalled: true })),
             onLoading: () => set(() => ({ loading: true })),
             onEnded: () => set(() => ({ ended: true })),
-            setFullscreen: (fullscreen) => set(({ aria }) => {
-              const title = fullscreen ? "Exit full screen (f)" : "Full screen (f)";
-              return {
-                fullscreen,
-                aria: {
-                  ...aria,
-                  fullscreen: title
-                }
-              };
-            }),
-            requestToggleFullscreen: () => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                requestedFullscreenLastTime: Date.now()
-              }
-            })),
-            setPictureInPicture: (pictureInPicture) => set(({ aria }) => {
-              const title = pictureInPicture ? "Exit mini player (i)" : "Mini player (i)";
-              return {
-                pictureInPicture,
-                aria: {
-                  ...aria,
-                  pictureInPicture: title
-                }
-              };
-            }),
-            requestTogglePictureInPicture: () => set(({ __controls }) => ({
-              __controls: {
-                ...__controls,
-                requestedPictureInPictureLastTime: Date.now()
-              }
-            })),
+            setFullscreen: (fullscreen) =>
+              set(({ aria }) => {
+                const title = fullscreen
+                  ? "Exit full screen (f)"
+                  : "Full screen (f)";
+                return {
+                  fullscreen,
+                  aria: {
+                    ...aria,
+                    fullscreen: title,
+                  },
+                };
+              }),
+            requestToggleFullscreen: () =>
+              set(({ __controls }) => ({
+                __controls: {
+                  ...__controls,
+                  requestedFullscreenLastTime: Date.now(),
+                },
+              })),
+            setPictureInPicture: (pictureInPicture) =>
+              set(({ aria }) => {
+                const title = pictureInPicture
+                  ? "Exit mini player (i)"
+                  : "Mini player (i)";
+                return {
+                  pictureInPicture,
+                  aria: {
+                    ...aria,
+                    pictureInPicture: title,
+                  },
+                };
+              }),
+            requestTogglePictureInPicture: () =>
+              set(({ __controls }) => ({
+                __controls: {
+                  ...__controls,
+                  requestedPictureInPictureLastTime: Date.now(),
+                },
+              })),
             setLive: (live) => set(() => ({ live })),
-            requestClip: () => set(({ __controls, __initialProps }) => ({
-              __controls: {
-                ...__controls,
-                requestedClipParams: __initialProps.clipLength ? getClipParams({
-                  requestedTime: Date.now(),
-                  clipLength: __initialProps.clipLength,
-                  playbackOffsetMs: __controls.playbackOffsetMs
-                }) : null
-              }
-            })),
-            requestVolume: (newVolume) => set(({ __controls }) => ({
-              volume: getBoundedVolume(newVolume),
-              __controls: {
-                ...__controls,
-                volume: newVolume === 0 ? newVolume : getBoundedVolume(newVolume),
-                muted: newVolume === 0
-              }
-            })),
-            setVolume: (newVolume) => set(({ __controls }) => ({
-              volume: getBoundedVolume(newVolume),
-              __controls: {
-                ...__controls,
-                muted: newVolume === 0
-              }
-            })),
-            requestToggleMute: (forceValue) => set(({ __controls }) => {
-              const previousVolume = getBoundedVolume(__controls.volume) || 0;
-              const nonMutedVolume = previousVolume > 0.01 ? previousVolume : DEFAULT_VOLUME_LEVEL;
-              const mutedVolume = 0;
-              const newMutedValue = forceValue ?? !__controls.muted;
-              return {
-                volume: newMutedValue ? mutedVolume : nonMutedVolume,
+            requestClip: () =>
+              set(({ __controls, __initialProps }) => ({
                 __controls: {
                   ...__controls,
-                  muted: newMutedValue
-                }
-              };
-            }),
-            onError: (rawError) => set(
-              ({
-                currentSource,
-                sortedSources,
-                __controls,
-                errorCount,
-                __device,
-                __initialProps,
-                videoQuality,
-                playbackRate
-              }) => {
-                const msSinceLastError = Date.now() - __controls.lastError;
-                const error = rawError ? {
-                  type: isAccessControlError(rawError) ? "access-control" : isBframesError(rawError) || isNotAcceptableError(rawError) ? "fallback" : isStreamOfflineError(rawError) ? "offline" : isPermissionsError(rawError) ? "permissions" : "unknown",
-                  message: rawError?.message ?? "Error with playback."
-                } : null;
-                if (__initialProps.onError) {
-                  try {
-                    __initialProps.onError(error);
-                  } catch (e) {
-                    console.error(e);
-                  }
-                }
-                const base = {
-                  error,
-                  ...error ? {
-                    errorCount: errorCount + 1,
-                    playing: false,
-                    __controls: {
-                      ...__controls,
-                      lastError: Date.now()
-                    }
-                  } : { __controls }
+                  requestedClipParams: __initialProps.clipLength
+                    ? getClipParams({
+                        requestedTime: Date.now(),
+                        clipLength: __initialProps.clipLength,
+                        playbackOffsetMs: __controls.playbackOffsetMs,
+                      })
+                    : null,
+                },
+              })),
+            requestVolume: (newVolume) =>
+              set(({ __controls }) => ({
+                volume: getBoundedVolume(newVolume),
+                __controls: {
+                  ...__controls,
+                  volume:
+                    newVolume === 0 ? newVolume : getBoundedVolume(newVolume),
+                  muted: newVolume === 0,
+                },
+              })),
+            setVolume: (newVolume) =>
+              set(({ __controls }) => ({
+                volume: getBoundedVolume(newVolume),
+                __controls: {
+                  ...__controls,
+                  muted: newVolume === 0,
+                },
+              })),
+            requestToggleMute: (forceValue) =>
+              set(({ __controls }) => {
+                const previousVolume = getBoundedVolume(__controls.volume) || 0;
+                const nonMutedVolume =
+                  previousVolume > 0.01 ? previousVolume : DEFAULT_VOLUME_LEVEL;
+                const mutedVolume = 0;
+                const newMutedValue = forceValue ?? !__controls.muted;
+                return {
+                  volume: newMutedValue ? mutedVolume : nonMutedVolume,
+                  __controls: {
+                    ...__controls,
+                    muted: newMutedValue,
+                  },
                 };
-                if (!error) {
-                  return base;
-                }
-                console.error(error);
-                if (error.type === "offline" || error.type === "access-control" || error.type === "permissions") {
-                  return base;
-                }
-                if (typeof sortedSources === "string" || !Array.isArray(sortedSources)) {
-                  return base;
-                }
-                if (msSinceLastError < errorCount * 500) {
-                  return base;
-                }
-                const currentSourceBaseUrl = currentSource ? new URL(currentSource.src) : "";
-                if (currentSourceBaseUrl) {
-                  currentSourceBaseUrl.search = "";
-                }
-                const currentSourceIndex = sortedSources.findIndex(
-                  (s) => s.src === currentSourceBaseUrl.toString()
-                );
-                const rotatedSources = [
-                  ...sortedSources.slice(currentSourceIndex + 1),
-                  ...sortedSources.slice(0, currentSourceIndex + 1)
-                ];
-                const hasRecentWebRTCTimeout = getHasRecentWebRTCTimeout(
-                  __initialProps.cacheWebRTCFailureMs
-                );
-                const canPlaySourceType = (src2) => {
-                  const hasOneWebRTCSource = sortedSources.some(
-                    (s) => s?.type === "webrtc"
-                  );
-                  if (__initialProps.lowLatency === "force" && hasOneWebRTCSource && src2.type !== "webrtc") {
-                    return false;
+              }),
+            onError: (rawError) =>
+              set(
+                ({
+                  currentSource,
+                  sortedSources,
+                  __controls,
+                  errorCount,
+                  __device,
+                  __initialProps,
+                  videoQuality,
+                  playbackRate,
+                }) => {
+                  const msSinceLastError = Date.now() - __controls.lastError;
+                  const error = rawError
+                    ? {
+                        type: isAccessControlError(rawError)
+                          ? "access-control"
+                          : isBframesError(rawError) ||
+                            isNotAcceptableError(rawError)
+                          ? "fallback"
+                          : isStreamOfflineError(rawError)
+                          ? "offline"
+                          : isPermissionsError(rawError)
+                          ? "permissions"
+                          : "unknown",
+                        message: rawError?.message ?? "Error with playback.",
+                      }
+                    : null;
+                  if (__initialProps.onError) {
+                    try {
+                      __initialProps.onError(error);
+                    } catch (e) {
+                      console.error(e);
+                    }
                   }
-                  if (__initialProps.lowLatency === false) {
-                    return src2.type !== "webrtc";
+                  const base = {
+                    error,
+                    ...(error
+                      ? {
+                          errorCount: errorCount + 1,
+                          playing: false,
+                          __controls: {
+                            ...__controls,
+                            lastError: Date.now(),
+                          },
+                        }
+                      : { __controls }),
+                  };
+                  if (!error) {
+                    return base;
                   }
-                  if (hasRecentWebRTCTimeout) {
-                    return src2.type !== "webrtc";
+                  console.error(error);
+                  if (
+                    error.type === "offline" ||
+                    error.type === "access-control" ||
+                    error.type === "permissions"
+                  ) {
+                    return base;
                   }
-                  return src2.type === "webrtc" ? __device.isWebRTCSupported : true;
-                };
-                const nextPlayableIndex = rotatedSources.findIndex(
-                  (s) => canPlaySourceType(s)
-                );
-                const nextSourceIndex = nextPlayableIndex !== -1 ? (currentSourceIndex + 1 + nextPlayableIndex) % sortedSources.length : -1;
-                const nextSource = nextSourceIndex !== -1 ? sortedSources[nextSourceIndex] : null;
-                const parsedSourceNew = parseCurrentSourceAndPlaybackId({
-                  accessKey: __initialProps?.accessKey ?? null,
-                  aspectRatio: __initialProps?.aspectRatio ?? null,
-                  isHlsSupported: __device.isHlsSupported,
-                  jwt: __initialProps?.jwt ?? null,
-                  playbackRate,
-                  sessionToken: __controls.sessionToken,
-                  source: nextSource,
-                  videoQuality
-                });
-                return {
-                  ...base,
-                  currentSource: parsedSourceNew?.currentSource ?? null,
-                  __controls: {
-                    ...base.__controls,
-                    playbackId: playbackId ?? parsedSourceNew?.playbackId ?? null
+                  if (
+                    typeof sortedSources === "string" ||
+                    !Array.isArray(sortedSources)
+                  ) {
+                    return base;
                   }
-                };
-              }
-            )
-          }
+                  if (msSinceLastError < errorCount * 500) {
+                    return base;
+                  }
+                  const currentSourceBaseUrl = currentSource
+                    ? new URL(currentSource.src)
+                    : "";
+                  if (currentSourceBaseUrl) {
+                    currentSourceBaseUrl.search = "";
+                  }
+                  const currentSourceIndex = sortedSources.findIndex(
+                    (s) => s.src === currentSourceBaseUrl.toString()
+                  );
+                  const rotatedSources = [
+                    ...sortedSources.slice(currentSourceIndex + 1),
+                    ...sortedSources.slice(0, currentSourceIndex + 1),
+                  ];
+                  const hasRecentWebRTCTimeout = getHasRecentWebRTCTimeout(
+                    __initialProps.cacheWebRTCFailureMs
+                  );
+                  const canPlaySourceType = (src2) => {
+                    const hasOneWebRTCSource = sortedSources.some(
+                      (s) => s?.type === "webrtc"
+                    );
+                    if (
+                      __initialProps.lowLatency === "force" &&
+                      hasOneWebRTCSource &&
+                      src2.type !== "webrtc"
+                    ) {
+                      return false;
+                    }
+                    if (__initialProps.lowLatency === false) {
+                      return src2.type !== "webrtc";
+                    }
+                    if (hasRecentWebRTCTimeout) {
+                      return src2.type !== "webrtc";
+                    }
+                    return src2.type === "webrtc"
+                      ? __device.isWebRTCSupported
+                      : true;
+                  };
+                  const nextPlayableIndex = rotatedSources.findIndex((s) =>
+                    canPlaySourceType(s)
+                  );
+                  const nextSourceIndex =
+                    nextPlayableIndex !== -1
+                      ? (currentSourceIndex + 1 + nextPlayableIndex) %
+                        sortedSources.length
+                      : -1;
+                  const nextSource =
+                    nextSourceIndex !== -1
+                      ? sortedSources[nextSourceIndex]
+                      : null;
+                  const parsedSourceNew = parseCurrentSourceAndPlaybackId({
+                    accessKey: __initialProps?.accessKey ?? null,
+                    aspectRatio: __initialProps?.aspectRatio ?? null,
+                    isHlsSupported: __device.isHlsSupported,
+                    jwt: __initialProps?.jwt ?? null,
+                    playbackRate,
+                    sessionToken: __controls.sessionToken,
+                    source: nextSource,
+                    videoQuality,
+                    forceNoToken: __initialProps?.forceNoToken,
+                  });
+                  return {
+                    ...base,
+                    currentSource: parsedSourceNew?.currentSource ?? null,
+                    __controls: {
+                      ...base.__controls,
+                      playbackId:
+                        playbackId ?? parsedSourceNew?.playbackId ?? null,
+                    },
+                  };
+                }
+              ),
+          },
         }),
         {
           name: "livepeer-media-controller",
@@ -1055,9 +1245,9 @@ var createControllerStore = ({
           // since these values are persisted across media, only persist volume & videoQuality
           partialize: ({ volume, videoQuality }) => ({
             volume,
-            videoQuality
+            videoQuality,
           }),
-          storage: createJSONStorage(() => storage)
+          storage: createJSONStorage(() => storage),
         }
       )
     )
@@ -1108,11 +1298,14 @@ var LegacyPlaybackMonitor = class {
   }
   calculateScore() {
     if (this.active) {
-      const latestPlaybackRecord = this.values.length > 0 ? this.values[this.values.length - 1] : void 0;
+      const latestPlaybackRecord =
+        this.values.length > 0 ? this.values[this.values.length - 1] : void 0;
       const currentValue = {
         clockTime: Date.now() * 1e-3,
         mediaTime: this.store.getState().progress,
-        score: latestPlaybackRecord ? this.valueToScore(latestPlaybackRecord) : 0
+        score: latestPlaybackRecord
+          ? this.valueToScore(latestPlaybackRecord)
+          : 0,
       };
       this.values.push(currentValue);
       if (this.values.length < 2) {
@@ -1132,7 +1325,11 @@ var LegacyPlaybackMonitor = class {
   }
   valueToScore(a, b) {
     const rate = this?.store?.getState?.()?.playbackRate ?? 1;
-    return (b?.mediaTime ?? this.store.getState().progress - a.mediaTime) / (b?.clockTime ?? Date.now() * 1e-3 - a.clockTime) / (rate === "constant" ? 1 : rate);
+    return (
+      (b?.mediaTime ?? this.store.getState().progress - a.mediaTime) /
+      (b?.clockTime ?? Date.now() * 1e-3 - a.clockTime) /
+      (rate === "constant" ? 1 : rate)
+    );
   }
 };
 var Timer = class {
@@ -1180,12 +1377,23 @@ var LegacyMetricsStatus = class {
     const currentState = store.getState();
     this.store = store;
     this.bootMs = bootMs;
-    const windowHref = typeof window !== "undefined" ? window?.location?.href ?? "" : "";
-    const pageUrl = isInIframe() ? typeof document !== "undefined" ? document?.referrer || windowHref : windowHref : windowHref;
+    const windowHref =
+      typeof window !== "undefined" ? window?.location?.href ?? "" : "";
+    const pageUrl = isInIframe()
+      ? typeof document !== "undefined"
+        ? document?.referrer || windowHref
+        : windowHref
+      : windowHref;
     const playerPrefix = currentState?.currentSource?.type ?? "unknown";
     const version = currentState?.__device.version ?? "unknown";
     this.currentMetrics = {
-      autoplay: currentState.__initialProps.autoPlay ? "autoplay" : currentState.__initialProps.preload === "auto" ? "preload-full" : currentState.__initialProps.preload === "metadata" ? "preload-metadata" : "standard",
+      autoplay: currentState.__initialProps.autoPlay
+        ? "autoplay"
+        : currentState.__initialProps.preload === "auto"
+        ? "preload-full"
+        : currentState.__initialProps.preload === "metadata"
+        ? "preload-metadata"
+        : "standard",
       duration: null,
       firstPlayback: null,
       nError: null,
@@ -1210,10 +1418,13 @@ var LegacyMetricsStatus = class {
         ""
       ),
       videoHeight: null,
-      videoWidth: null
+      videoWidth: null,
     };
     this.destroy = store.subscribe((state, prevState) => {
-      if (this.requestedPlayTime === null && state.__controls.playLastTime !== 0) {
+      if (
+        this.requestedPlayTime === null &&
+        state.__controls.playLastTime !== 0
+      ) {
         this.requestedPlayTime = Math.max(
           state.__controls.playLastTime - bootMs,
           0
@@ -1237,7 +1448,11 @@ var LegacyMetricsStatus = class {
           this.timeWaiting.stop();
         }
       }
-      if (opts?.disableProgressListener !== true && state.progress !== prevState.progress && !this.timeUnpaused.startTime) {
+      if (
+        opts?.disableProgressListener !== true &&
+        state.progress !== prevState.progress &&
+        !this.timeUnpaused.startTime
+      ) {
         this.timeStalled.stop();
         this.timeWaiting.stop();
         this.timeUnpaused.start();
@@ -1289,8 +1504,10 @@ var LegacyMetricsStatus = class {
   getMetrics() {
     const currentMetrics = {
       ...this.currentMetrics,
-      playerHeight: this.store.getState().__controls.size?.container?.height || null,
-      playerWidth: this.store.getState().__controls.size?.container?.width || null,
+      playerHeight:
+        this.store.getState().__controls.size?.container?.height || null,
+      playerWidth:
+        this.store.getState().__controls.size?.container?.width || null,
       videoWidth: this.store.getState().__controls.size?.media?.width || null,
       videoHeight: this.store.getState().__controls.size?.media?.height || null,
       duration: this.store.getState().duration || null,
@@ -1303,13 +1520,19 @@ var LegacyMetricsStatus = class {
       // this is the amount of time that a video has had to preload content, from boot until play was requested
       preloadTime: this.requestedPlayTime,
       // time from when the first `play` event is emitted and the first progress update
-      ttff: this.firstFrameTime && this.requestedPlayTime && this.firstFrameTime > 0 && this.requestedPlayTime > 0 ? Math.max(this.firstFrameTime - this.requestedPlayTime, 0) : null
+      ttff:
+        this.firstFrameTime &&
+        this.requestedPlayTime &&
+        this.firstFrameTime > 0 &&
+        this.requestedPlayTime > 0
+          ? Math.max(this.firstFrameTime - this.requestedPlayTime, 0)
+          : null,
     };
     const previousMetrics = this.previousMetrics;
     this.previousMetrics = currentMetrics;
     return {
       current: currentMetrics,
-      previous: previousMetrics
+      previous: previousMetrics,
     };
   }
 };
@@ -1317,8 +1540,7 @@ function addLegacyMediaMetricsToStore(store, opts) {
   const bootMs = Date.now();
   const defaultResponse = {
     metrics: null,
-    destroy: () => {
-    }
+    destroy: () => {},
   };
   if (!store) {
     return defaultResponse;
@@ -1346,7 +1568,10 @@ function addLegacyMediaMetricsToStore(store, opts) {
     let key;
     for (key in metrics.current) {
       const val = metrics.current[key];
-      const shouldSendValue = typeof val === "number" ? Number.isFinite(val) && !Number.isNaN(val) && val >= 0 : Boolean(val);
+      const shouldSendValue =
+        typeof val === "number"
+          ? Number.isFinite(val) && !Number.isNaN(val) && val >= 0
+          : Boolean(val);
       if (shouldSendValue && val !== metrics?.previous?.[key]) {
         d[key] = val;
       }
@@ -1361,7 +1586,11 @@ function addLegacyMediaMetricsToStore(store, opts) {
       report();
     }, 1e3);
   };
-  const createNewWebSocket = async (playbackId, currentSource, numRetries = 0) => {
+  const createNewWebSocket = async (
+    playbackId,
+    currentSource,
+    numRetries = 0
+  ) => {
     try {
       if (!playbackId || !currentSource) {
         return null;
@@ -1371,7 +1600,7 @@ function addLegacyMediaMetricsToStore(store, opts) {
       const reportingWebsocketUrl = await getMetricsReportingWebsocketUrl({
         playbackId,
         playbackUrl: currentSource,
-        sessionToken: store.getState().__controls.sessionToken
+        sessionToken: store.getState().__controls.sessionToken,
       });
       if (reportingWebsocketUrl) {
         const newWebSocket = new WebSocket(reportingWebsocketUrl);
@@ -1392,18 +1621,15 @@ function addLegacyMediaMetricsToStore(store, opts) {
           if (timer) {
             clearTimeout(timer);
           }
-          setTimeout(
-            () => {
-              if (reportingActive) {
-                websocketPromise = createNewWebSocket(
-                  playbackId,
-                  currentSource,
-                  numRetries + 1
-                );
-              }
-            },
-            2 ** numRetries * 1e3
-          );
+          setTimeout(() => {
+            if (reportingActive) {
+              websocketPromise = createNewWebSocket(
+                playbackId,
+                currentSource,
+                numRetries + 1
+              );
+            }
+          }, 2 ** numRetries * 1e3);
         });
         return newWebSocket;
       }
@@ -1416,7 +1642,7 @@ function addLegacyMediaMetricsToStore(store, opts) {
     (state) => ({
       playbackId: state.__controls.playbackId,
       finalUrl: state.currentUrl,
-      type: state.currentSource?.type
+      type: state.currentSource?.type,
     }),
     (state) => {
       if (state?.playbackId && state?.finalUrl) {
@@ -1427,26 +1653,41 @@ function addLegacyMediaMetricsToStore(store, opts) {
       fireImmediately: true,
       equalityFn: (a, b) => {
         return a.playbackId === b.playbackId && Boolean(a.finalUrl);
-      }
+      },
     }
   );
   try {
     const destroyTtffListener = store.subscribe((state, prevState) => {
-      if (state.playing !== prevState.playing && metricsStatus.getFirstPlayback() === null) {
+      if (
+        state.playing !== prevState.playing &&
+        metricsStatus.getFirstPlayback() === null
+      ) {
         metricsStatus.setFirstPlayback();
       }
-      if (state.progress !== prevState.progress && metricsStatus.getFirstFrameTime() === null) {
+      if (
+        state.progress !== prevState.progress &&
+        metricsStatus.getFirstFrameTime() === null
+      ) {
         metricsStatus.setFirstFrameTime();
       }
-      if (state.error?.message && state.error?.message !== prevState.error?.message) {
+      if (
+        state.error?.message &&
+        state.error?.message !== prevState.error?.message
+      ) {
         metricsStatus.addError(state.error.message);
       }
     });
     const destroyMonitorListener = store.subscribe((state, prevState) => {
-      if (state.playing !== prevState.playing && state.playing || state.loading !== prevState.loading && state.loading) {
+      if (
+        (state.playing !== prevState.playing && state.playing) ||
+        (state.loading !== prevState.loading && state.loading)
+      ) {
         monitor.init();
       }
-      if (state.__controls.requestedRangeToSeekTo !== prevState.__controls.requestedRangeToSeekTo) {
+      if (
+        state.__controls.requestedRangeToSeekTo !==
+        prevState.__controls.requestedRangeToSeekTo
+      ) {
         monitor.reset();
       }
       if (state.playing !== prevState.playing && !state.playing) {
@@ -1493,34 +1734,37 @@ var isObject = (obj) => {
   }
   return false;
 };
-var merge = (...objects) => objects.reduce((result, current) => {
-  if (Array.isArray(current)) {
-    throw new TypeError(
-      "Arguments provided to ts-deepmerge must be objects, not arrays."
-    );
-  }
-  Object.keys(current).forEach((key) => {
-    if (["__proto__", "constructor", "prototype"].includes(key)) {
-      return;
-    }
-    if (Array.isArray(result[key]) && Array.isArray(current[key])) {
-      result[key] = merge.options.mergeArrays ? Array.from(new Set(result[key].concat(current[key]))) : current[key];
-    } else if (isObject(result[key]) && isObject(current[key])) {
-      result[key] = merge(result[key], current[key]);
-    } else {
-      result[key] = current[key];
+var merge = (...objects) =>
+  objects.reduce((result, current) => {
+    if (Array.isArray(current)) {
+      throw new TypeError(
+        "Arguments provided to ts-deepmerge must be objects, not arrays."
+      );
     }
-  });
-  return result;
-}, {});
+    Object.keys(current).forEach((key) => {
+      if (["__proto__", "constructor", "prototype"].includes(key)) {
+        return;
+      }
+      if (Array.isArray(result[key]) && Array.isArray(current[key])) {
+        result[key] = merge.options.mergeArrays
+          ? Array.from(new Set(result[key].concat(current[key])))
+          : current[key];
+      } else if (isObject(result[key]) && isObject(current[key])) {
+        result[key] = merge(result[key], current[key]);
+      } else {
+        result[key] = current[key];
+      }
+    });
+    return result;
+  }, {});
 var defaultOptions = {
-  mergeArrays: true
+  mergeArrays: true,
 };
 merge.options = defaultOptions;
 merge.withOptions = (options, ...objects) => {
   merge.options = {
     mergeArrays: true,
-    ...options
+    ...options,
   };
   const result = merge(...objects);
   merge.options = defaultOptions;
@@ -1543,8 +1787,7 @@ function warn(message, id) {
 var globalLoadTimestampMs = Date.now();
 function addMetricsToStore(store, opts) {
   const defaultResponse = {
-    destroy: () => {
-    }
+    destroy: () => {},
   };
   if (!store) {
     return defaultResponse;
@@ -1553,19 +1796,19 @@ function addMetricsToStore(store, opts) {
     return defaultResponse;
   }
   const monitor = new MetricsMonitor(store, {
-    disableProgressListener: opts?.disableProgressListener
+    disableProgressListener: opts?.disableProgressListener,
   });
   const isSendBeaconAvailable = "sendBeacon" in window.navigator;
   const interval = opts?.interval ?? 5e3;
   const eventBuffer = new PlaybackEventBuffer();
   const destroyFinalUrlListener = store.subscribe(
     (state) => ({
-      finalUrl: state.currentUrl
+      finalUrl: state.currentUrl,
     }),
     async (state) => {
       if (state?.finalUrl) {
         const url = await getMetricsReportingPOSTUrl({
-          playbackUrl: state.finalUrl
+          playbackUrl: state.finalUrl,
         });
         if (url) {
           store.getState().__controlsFunctions.setMetricsReportingUrl(url);
@@ -1576,7 +1819,7 @@ function addMetricsToStore(store, opts) {
       fireImmediately: true,
       equalityFn: (a, b) => {
         return a.finalUrl === b.finalUrl;
-      }
+      },
     }
   );
   const destroyErrorListener = store.subscribe(
@@ -1584,19 +1827,21 @@ function addMetricsToStore(store, opts) {
     async (error) => {
       if (error) {
         eventBuffer.addEvent(
-          error.type === "offline" || error.type === "fallback" ? {
-            id: generateRandomToken(),
-            type: "warning",
-            timestamp: Date.now(),
-            category: error.type,
-            message: error.message
-          } : {
-            id: generateRandomToken(),
-            type: "error",
-            timestamp: Date.now(),
-            category: error.type,
-            message: error.message
-          }
+          error.type === "offline" || error.type === "fallback"
+            ? {
+                id: generateRandomToken(),
+                type: "warning",
+                timestamp: Date.now(),
+                category: error.type,
+                message: error.message,
+              }
+            : {
+                id: generateRandomToken(),
+                type: "error",
+                timestamp: Date.now(),
+                category: error.type,
+                message: error.message,
+              }
         );
       }
     }
@@ -1607,7 +1852,7 @@ function addMetricsToStore(store, opts) {
       eventBuffer.addEvent({
         id: generateRandomToken(),
         type: "play",
-        timestamp
+        timestamp,
       });
     }
   );
@@ -1617,7 +1862,7 @@ function addMetricsToStore(store, opts) {
       eventBuffer.addEvent({
         id: generateRandomToken(),
         type: "pause",
-        timestamp
+        timestamp,
       });
     }
   );
@@ -1630,7 +1875,7 @@ function addMetricsToStore(store, opts) {
           type: "clip",
           timestamp: Date.now(),
           startTime: params.startTime,
-          endTime: params.endTime
+          endTime: params.endTime,
         });
       }
     }
@@ -1641,7 +1886,7 @@ function addMetricsToStore(store, opts) {
       eventBuffer.addEvent({
         id: generateRandomToken(),
         type: pictureInPicture ? "enter-pip" : "exit-pip",
-        timestamp: Date.now()
+        timestamp: Date.now(),
       });
     }
   );
@@ -1651,7 +1896,7 @@ function addMetricsToStore(store, opts) {
       eventBuffer.addEvent({
         id: generateRandomToken(),
         type: fullscreen ? "enter-fullscreen" : "exit-fullscreen",
-        timestamp: Date.now()
+        timestamp: Date.now(),
       });
     }
   );
@@ -1662,7 +1907,7 @@ function addMetricsToStore(store, opts) {
         eventBuffer.addEvent({
           id: generateRandomToken(),
           type: "can-play",
-          timestamp: Date.now()
+          timestamp: Date.now(),
         });
       }
     }
@@ -1674,7 +1919,7 @@ function addMetricsToStore(store, opts) {
         eventBuffer.addEvent({
           id: generateRandomToken(),
           type: "ended",
-          timestamp: Date.now()
+          timestamp: Date.now(),
         });
       }
     }
@@ -1686,7 +1931,7 @@ function addMetricsToStore(store, opts) {
         id: generateRandomToken(),
         type: "rate",
         timestamp: Date.now(),
-        payload: playbackRate
+        payload: playbackRate,
       });
     }
   );
@@ -1697,7 +1942,7 @@ function addMetricsToStore(store, opts) {
         id: generateRandomToken(),
         type: "video-quality",
         timestamp: Date.now(),
-        payload: videoQuality
+        payload: videoQuality,
       });
     }
   );
@@ -1708,7 +1953,7 @@ function addMetricsToStore(store, opts) {
         id: generateRandomToken(),
         type: "seek",
         timestamp: Date.now(),
-        payload: rangeToSeekTo
+        payload: rangeToSeekTo,
       });
     }
   );
@@ -1721,7 +1966,7 @@ function addMetricsToStore(store, opts) {
     "time_errored_ms",
     "time_stalled_ms",
     "time_playing_ms",
-    "time_waiting_ms"
+    "time_waiting_ms",
   ]);
   const vct = new ValueChangeTracker([
     "autoplay_status",
@@ -1735,191 +1980,203 @@ function addMetricsToStore(store, opts) {
     "player_width_px",
     "player_height_px",
     "window_height_px",
-    "window_width_px"
+    "window_width_px",
   ]);
   let firstFrameSent = false;
-  const sendEvents = ({ isUnloading } = { isUnloading: false }) => async () => {
-    const currentState = store.getState();
-    const currentControlsState = currentState.__controls;
-    if (!currentState.currentSource) {
-      warn("Not sending metrics since no current playback source parsed.");
-      return;
-    }
-    if (!currentControlsState.playbackId) {
-      warn("Not sending metrics since no playback ID parsed.");
-      return;
-    }
-    const metricsSnapshot = monitor.getMetrics();
-    if (!firstFrameSent && monitor.firstFrameTimestamp) {
+  const sendEvents =
+    ({ isUnloading } = { isUnloading: false }) =>
+    async () => {
+      const currentState = store.getState();
+      const currentControlsState = currentState.__controls;
+      if (!currentState.currentSource) {
+        warn("Not sending metrics since no current playback source parsed.");
+        return;
+      }
+      if (!currentControlsState.playbackId) {
+        warn("Not sending metrics since no playback ID parsed.");
+        return;
+      }
+      const metricsSnapshot = monitor.getMetrics();
+      if (!firstFrameSent && monitor.firstFrameTimestamp) {
+        eventBuffer.addEvent({
+          id: generateRandomToken(),
+          type: "first-frame",
+          timestamp: monitor.firstFrameTimestamp,
+        });
+        firstFrameSent = true;
+      }
       eventBuffer.addEvent({
         id: generateRandomToken(),
-        type: "first-frame",
-        timestamp: monitor.firstFrameTimestamp
+        type: "heartbeat",
+        timestamp: Date.now(),
+        errors: ic.calculateIncrement("errors", metricsSnapshot.errorCount),
+        warnings: ic.calculateIncrement(
+          "warnings",
+          metricsSnapshot.warningCount
+        ),
+        stalled_count: ic.calculateIncrement(
+          "stalled_count",
+          metricsSnapshot.stalledCount
+        ),
+        waiting_count: ic.calculateIncrement(
+          "waiting_count",
+          metricsSnapshot.waitingCount
+        ),
+        time_errored_ms: ic.calculateIncrement(
+          "time_errored_ms",
+          metricsSnapshot.timeErrored
+        ),
+        time_warning_ms: ic.calculateIncrement(
+          "time_warning_ms",
+          metricsSnapshot.timeWarning
+        ),
+        time_stalled_ms: ic.calculateIncrement(
+          "time_stalled_ms",
+          metricsSnapshot.timeStalled
+        ),
+        time_playing_ms: ic.calculateIncrement(
+          "time_playing_ms",
+          metricsSnapshot.timePlaying
+        ),
+        time_waiting_ms: ic.calculateIncrement(
+          "time_waiting_ms",
+          metricsSnapshot.timeWaiting
+        ),
+        // The properties below are only sent once.
+        autoplay_status: vct.sendIfChanged(
+          "autoplay_status",
+          currentState.__initialProps.autoPlay ? "autoplay" : "none"
+        ),
+        mount_to_play_ms: vct.sendIfChanged(
+          "mount_to_play_ms",
+          metricsSnapshot.mountToPlay ?? void 0
+        ),
+        mount_to_first_frame_ms: vct.sendIfChanged(
+          "mount_to_first_frame_ms",
+          metricsSnapshot.mountToFirstFrame ?? void 0
+        ),
+        play_to_first_frame_ms: vct.sendIfChanged(
+          "play_to_first_frame_ms",
+          metricsSnapshot.playToFirstFrame ?? void 0
+        ),
+        duration_ms: currentState?.live
+          ? void 0
+          : vct.sendIfChanged(
+              "duration_ms",
+              metricsSnapshot.duration ?? void 0
+            ),
+        offset_ms: vct.sendIfChanged(
+          "offset_ms",
+          metricsSnapshot.offset ?? void 0
+        ),
+        // The properties below are only sent when they change.
+        video_height_px: vct.sendIfChanged(
+          "video_height_px",
+          metricsSnapshot.videoHeight ?? void 0
+        ),
+        video_width_px: vct.sendIfChanged(
+          "video_width_px",
+          metricsSnapshot.videoWidth ?? void 0
+        ),
+        player_height_px: vct.sendIfChanged(
+          "player_height_px",
+          metricsSnapshot.playerHeight ?? void 0
+        ),
+        player_width_px: vct.sendIfChanged(
+          "player_width_px",
+          metricsSnapshot.playerWidth ?? void 0
+        ),
+        window_height_px: vct.sendIfChanged(
+          "window_height_px",
+          metricsSnapshot.windowHeight ?? void 0
+        ),
+        window_width_px: vct.sendIfChanged(
+          "window_width_px",
+          metricsSnapshot.windowWidth ?? void 0
+        ),
       });
-      firstFrameSent = true;
-    }
-    eventBuffer.addEvent({
-      id: generateRandomToken(),
-      type: "heartbeat",
-      timestamp: Date.now(),
-      errors: ic.calculateIncrement("errors", metricsSnapshot.errorCount),
-      warnings: ic.calculateIncrement(
-        "warnings",
-        metricsSnapshot.warningCount
-      ),
-      stalled_count: ic.calculateIncrement(
-        "stalled_count",
-        metricsSnapshot.stalledCount
-      ),
-      waiting_count: ic.calculateIncrement(
-        "waiting_count",
-        metricsSnapshot.waitingCount
-      ),
-      time_errored_ms: ic.calculateIncrement(
-        "time_errored_ms",
-        metricsSnapshot.timeErrored
-      ),
-      time_warning_ms: ic.calculateIncrement(
-        "time_warning_ms",
-        metricsSnapshot.timeWarning
-      ),
-      time_stalled_ms: ic.calculateIncrement(
-        "time_stalled_ms",
-        metricsSnapshot.timeStalled
-      ),
-      time_playing_ms: ic.calculateIncrement(
-        "time_playing_ms",
-        metricsSnapshot.timePlaying
-      ),
-      time_waiting_ms: ic.calculateIncrement(
-        "time_waiting_ms",
-        metricsSnapshot.timeWaiting
-      ),
-      // The properties below are only sent once.
-      autoplay_status: vct.sendIfChanged(
-        "autoplay_status",
-        currentState.__initialProps.autoPlay ? "autoplay" : "none"
-      ),
-      mount_to_play_ms: vct.sendIfChanged(
-        "mount_to_play_ms",
-        metricsSnapshot.mountToPlay ?? void 0
-      ),
-      mount_to_first_frame_ms: vct.sendIfChanged(
-        "mount_to_first_frame_ms",
-        metricsSnapshot.mountToFirstFrame ?? void 0
-      ),
-      play_to_first_frame_ms: vct.sendIfChanged(
-        "play_to_first_frame_ms",
-        metricsSnapshot.playToFirstFrame ?? void 0
-      ),
-      duration_ms: currentState?.live ? void 0 : vct.sendIfChanged(
-        "duration_ms",
-        metricsSnapshot.duration ?? void 0
-      ),
-      offset_ms: vct.sendIfChanged(
-        "offset_ms",
-        metricsSnapshot.offset ?? void 0
-      ),
-      // The properties below are only sent when they change.
-      video_height_px: vct.sendIfChanged(
-        "video_height_px",
-        metricsSnapshot.videoHeight ?? void 0
-      ),
-      video_width_px: vct.sendIfChanged(
-        "video_width_px",
-        metricsSnapshot.videoWidth ?? void 0
-      ),
-      player_height_px: vct.sendIfChanged(
-        "player_height_px",
-        metricsSnapshot.playerHeight ?? void 0
-      ),
-      player_width_px: vct.sendIfChanged(
-        "player_width_px",
-        metricsSnapshot.playerWidth ?? void 0
-      ),
-      window_height_px: vct.sendIfChanged(
-        "window_height_px",
-        metricsSnapshot.windowHeight ?? void 0
-      ),
-      window_width_px: vct.sendIfChanged(
-        "window_width_px",
-        metricsSnapshot.windowWidth ?? void 0
-      )
-    });
-    const internalEvents = eventBuffer.getInternalEvents();
-    try {
-      await opts?.onPlaybackEvents?.(internalEvents);
-    } catch (e) {
-      console.error(e);
-      eventBuffer.onInternalFailure(internalEvents);
-    }
-    const metricsUrl = currentState.metricsReportingUrl;
-    if (metricsUrl) {
-      const abortController = new AbortController();
-      const id = setTimeout(
-        () => abortController.abort(),
-        interval - 500
-        // we abort 500ms before the next request is scheduled
-      );
-      const externalEvents = eventBuffer.getExternalEvents();
-      if (isUnloading && externalEvents.length === 0) {
-        return;
-      }
+      const internalEvents = eventBuffer.getInternalEvents();
       try {
-        const windowHref = typeof window !== "undefined" ? window?.location?.href ?? null : null;
-        const pageUrlString = isInIframe2() ? typeof document !== "undefined" ? document?.referrer || windowHref : windowHref : windowHref;
-        const pageUrl = pageUrlString ? new URL(pageUrlString) : null;
-        const playerPrefix = currentState?.currentSource?.type ?? "unknown";
-        const version = currentState?.__device.version ?? "unknown";
-        const sessionData = {
-          live: currentState.live,
-          session_id: currentControlsState.sessionToken,
-          playback_id: currentControlsState.playbackId,
-          protocol: currentState.currentSource.mime ?? void 0,
-          domain: pageUrl?.hostname ?? null,
-          path: pageUrl?.pathname ?? null,
-          params: pageUrl?.search ?? null,
-          hash: pageUrl?.hash ?? null,
-          source_url: currentState.currentSource.src,
-          player: playerPrefix,
-          version,
-          user_agent: String(currentState?.__device?.userAgent ?? "").replace(
-            /\\|"/gm,
-            ""
-          ),
-          uid: currentState.__initialProps.viewerId ?? void 0,
-          events: externalEvents
-        };
-        const data = JSON.stringify(sessionData);
-        if (isUnloading && isSendBeaconAvailable) {
-          const success = window?.navigator?.sendBeacon?.(metricsUrl, data);
-          if (!success) {
-            throw new Error("Beacon response was not OK");
-          }
-        } else {
-          const response = await fetch(metricsUrl, {
-            method: "POST",
-            mode: "cors",
-            body: data,
-            signal: abortController.signal
-          });
-          await response.text();
-          if (!response.ok) {
-            throw new Error("Fetch response was not OK");
-          }
-        }
+        await opts?.onPlaybackEvents?.(internalEvents);
       } catch (e) {
-        console.error(
-          new Error(
-            e?.message ?? "Error with metrics reporting, re-enqueuing events..."
-          )
+        console.error(e);
+        eventBuffer.onInternalFailure(internalEvents);
+      }
+      const metricsUrl = currentState.metricsReportingUrl;
+      if (metricsUrl) {
+        const abortController = new AbortController();
+        const id = setTimeout(
+          () => abortController.abort(),
+          interval - 500
+          // we abort 500ms before the next request is scheduled
         );
-        eventBuffer.onExternalFailure(externalEvents);
-      } finally {
-        clearTimeout(id);
+        const externalEvents = eventBuffer.getExternalEvents();
+        if (isUnloading && externalEvents.length === 0) {
+          return;
+        }
+        try {
+          const windowHref =
+            typeof window !== "undefined"
+              ? window?.location?.href ?? null
+              : null;
+          const pageUrlString = isInIframe2()
+            ? typeof document !== "undefined"
+              ? document?.referrer || windowHref
+              : windowHref
+            : windowHref;
+          const pageUrl = pageUrlString ? new URL(pageUrlString) : null;
+          const playerPrefix = currentState?.currentSource?.type ?? "unknown";
+          const version = currentState?.__device.version ?? "unknown";
+          const sessionData = {
+            live: currentState.live,
+            session_id: currentControlsState.sessionToken,
+            playback_id: currentControlsState.playbackId,
+            protocol: currentState.currentSource.mime ?? void 0,
+            domain: pageUrl?.hostname ?? null,
+            path: pageUrl?.pathname ?? null,
+            params: pageUrl?.search ?? null,
+            hash: pageUrl?.hash ?? null,
+            source_url: currentState.currentSource.src,
+            player: playerPrefix,
+            version,
+            user_agent: String(currentState?.__device?.userAgent ?? "").replace(
+              /\\|"/gm,
+              ""
+            ),
+            uid: currentState.__initialProps.viewerId ?? void 0,
+            events: externalEvents,
+          };
+          const data = JSON.stringify(sessionData);
+          if (isUnloading && isSendBeaconAvailable) {
+            const success = window?.navigator?.sendBeacon?.(metricsUrl, data);
+            if (!success) {
+              throw new Error("Beacon response was not OK");
+            }
+          } else {
+            const response = await fetch(metricsUrl, {
+              method: "POST",
+              mode: "cors",
+              body: data,
+              signal: abortController.signal,
+            });
+            await response.text();
+            if (!response.ok) {
+              throw new Error("Fetch response was not OK");
+            }
+          }
+        } catch (e) {
+          console.error(
+            new Error(
+              e?.message ??
+                "Error with metrics reporting, re-enqueuing events..."
+            )
+          );
+          eventBuffer.onExternalFailure(externalEvents);
+        } finally {
+          clearTimeout(id);
+        }
       }
-    }
-  };
+    };
   const eventsTimer = setInterval(sendEvents(), interval);
   const unloadEvent = "onpagehide" in self ? "pagehide" : "unload";
   const unloadingCallback = sendEvents({ isUnloading: true });
@@ -1948,7 +2205,7 @@ function addMetricsToStore(store, opts) {
       destroySeekListener?.();
       destroyVideoQualityListener?.();
       window?.removeEventListener?.("visibilitychange", onVisibilityChange);
-    }
+    },
   };
 }
 function isInIframe2() {
@@ -1995,20 +2252,39 @@ var PlaybackEventBuffer = class {
           warnings: existingEvent.warnings + newEvent.warnings,
           stalled_count: existingEvent.stalled_count + newEvent.stalled_count,
           waiting_count: existingEvent.waiting_count + newEvent.waiting_count,
-          time_warning_ms: existingEvent.time_warning_ms + newEvent.time_warning_ms,
-          time_errored_ms: existingEvent.time_errored_ms + newEvent.time_errored_ms,
-          time_stalled_ms: existingEvent.time_stalled_ms + newEvent.time_stalled_ms,
-          time_playing_ms: existingEvent.time_playing_ms + newEvent.time_playing_ms,
-          time_waiting_ms: existingEvent.time_waiting_ms + newEvent.time_waiting_ms,
-          ...existingEvent.mount_to_first_frame_ms || newEvent.mount_to_first_frame_ms ? {
-            mount_to_first_frame_ms: (existingEvent.mount_to_first_frame_ms ?? 0) + (newEvent.mount_to_first_frame_ms ?? 0)
-          } : {},
-          ...existingEvent.mount_to_play_ms || newEvent.mount_to_play_ms ? {
-            mount_to_play_ms: (existingEvent.mount_to_play_ms ?? 0) + (newEvent.mount_to_play_ms ?? 0)
-          } : {},
-          ...existingEvent.play_to_first_frame_ms || newEvent.play_to_first_frame_ms ? {
-            play_to_first_frame_ms: (existingEvent.play_to_first_frame_ms ?? 0) + (newEvent.play_to_first_frame_ms ?? 0)
-          } : {}
+          time_warning_ms:
+            existingEvent.time_warning_ms + newEvent.time_warning_ms,
+          time_errored_ms:
+            existingEvent.time_errored_ms + newEvent.time_errored_ms,
+          time_stalled_ms:
+            existingEvent.time_stalled_ms + newEvent.time_stalled_ms,
+          time_playing_ms:
+            existingEvent.time_playing_ms + newEvent.time_playing_ms,
+          time_waiting_ms:
+            existingEvent.time_waiting_ms + newEvent.time_waiting_ms,
+          ...(existingEvent.mount_to_first_frame_ms ||
+          newEvent.mount_to_first_frame_ms
+            ? {
+                mount_to_first_frame_ms:
+                  (existingEvent.mount_to_first_frame_ms ?? 0) +
+                  (newEvent.mount_to_first_frame_ms ?? 0),
+              }
+            : {}),
+          ...(existingEvent.mount_to_play_ms || newEvent.mount_to_play_ms
+            ? {
+                mount_to_play_ms:
+                  (existingEvent.mount_to_play_ms ?? 0) +
+                  (newEvent.mount_to_play_ms ?? 0),
+              }
+            : {}),
+          ...(existingEvent.play_to_first_frame_ms ||
+          newEvent.play_to_first_frame_ms
+            ? {
+                play_to_first_frame_ms:
+                  (existingEvent.play_to_first_frame_ms ?? 0) +
+                  (newEvent.play_to_first_frame_ms ?? 0),
+              }
+            : {}),
         };
         this.externalBuffer[existingEventIndex] = mergedEvent;
       }
@@ -2048,13 +2324,10 @@ var PlaybackEventBuffer = class {
 var IncrementalCounter = class {
   counts;
   constructor(keys) {
-    this.counts = keys.reduce(
-      (acc, key) => {
-        acc[key] = 0;
-        return acc;
-      },
-      {}
-    );
+    this.counts = keys.reduce((acc, key) => {
+      acc[key] = 0;
+      return acc;
+    }, {});
   }
   calculateIncrement(key, newCount) {
     if (newCount < this.counts[key]) {
@@ -2068,13 +2341,10 @@ var IncrementalCounter = class {
 var ValueChangeTracker = class {
   lastValues;
   constructor(keys) {
-    this.lastValues = keys.reduce(
-      (acc, key) => {
-        acc[key] = void 0;
-        return acc;
-      },
-      {}
-    );
+    this.lastValues = keys.reduce((acc, key) => {
+      acc[key] = void 0;
+      return acc;
+    }, {});
   }
   sendIfChanged(key, newValue) {
     if (this.lastValues[key] !== newValue) {
@@ -2140,7 +2410,7 @@ var MetricsMonitor = class {
       videoWidth: null,
       waitingCount: 0,
       windowHeight: null,
-      windowWidth: null
+      windowWidth: null,
     };
     const destroyFirstPlayListener = store.subscribe(
       (state) => state.__controls.playLastTime,
@@ -2184,7 +2454,10 @@ var MetricsMonitor = class {
     const destroyProgressListener = store.subscribe(
       (state) => state.progress,
       async () => {
-        if (opts.disableProgressListener !== true && !this.timerPlaying.startTime) {
+        if (
+          opts.disableProgressListener !== true &&
+          !this.timerPlaying.startTime
+        ) {
           this.timerWarning.stop();
           this.timerErrored.stop();
           this.timerStalled.stop();
@@ -2198,7 +2471,10 @@ var MetricsMonitor = class {
             0
           );
         }
-        if (this.currentMetrics.playToFirstFrame === null && this.currentMetrics.mountToPlay !== null) {
+        if (
+          this.currentMetrics.playToFirstFrame === null &&
+          this.currentMetrics.mountToPlay !== null
+        ) {
           this.currentMetrics.playToFirstFrame = Math.max(
             now - this.currentMetrics.mountToPlay - globalLoadTimestampMs,
             0
@@ -2211,7 +2487,8 @@ var MetricsMonitor = class {
       (state) => state.error,
       async (error) => {
         if (error?.type) {
-          const isWarning = error.type === "offline" || error.type === "fallback";
+          const isWarning =
+            error.type === "offline" || error.type === "fallback";
           if (isWarning) {
             this.timerWarning.start();
           } else {
@@ -2267,13 +2544,19 @@ var MetricsMonitor = class {
     const duration = this.store.getState().duration;
     const currentMetrics = {
       ...this.currentMetrics,
-      playerHeight: this.store.getState().__controls.size?.container?.height || null,
-      playerWidth: this.store.getState().__controls.size?.container?.width || null,
+      playerHeight:
+        this.store.getState().__controls.size?.container?.height || null,
+      playerWidth:
+        this.store.getState().__controls.size?.container?.width || null,
       videoWidth: this.store.getState().__controls.size?.media?.width || null,
       videoHeight: this.store.getState().__controls.size?.media?.height || null,
       windowWidth: this.store.getState().__controls.size?.window?.width || null,
-      windowHeight: this.store.getState().__controls.size?.window?.height || null,
-      duration: Number.isFinite(duration) && !Number.isNaN(duration) ? Math.floor(duration * 1e3) : null,
+      windowHeight:
+        this.store.getState().__controls.size?.window?.height || null,
+      duration:
+        Number.isFinite(duration) && !Number.isNaN(duration)
+          ? Math.floor(duration * 1e3)
+          : null,
       waitingCount: this.timerWaiting.getCountStarts(),
       stalledCount: this.timerStalled.getCountStarts(),
       timeWarning: this.timerWarning.getTotalTime(),
@@ -2281,7 +2564,7 @@ var MetricsMonitor = class {
       timeWaiting: this.timerWaiting.getTotalTime(),
       timeStalled: this.timerStalled.getTotalTime(),
       timePlaying: this.timerPlaying.getTotalTime(),
-      offset: this.store.getState().__controls.playbackOffsetMs ?? null
+      offset: this.store.getState().__controls.playbackOffsetMs ?? null,
     };
     return currentMetrics;
   }
@@ -2292,6 +2575,6 @@ export {
   calculateVideoQualityDimensions,
   createControllerStore,
   getBoundedVolume,
-  getMediaSourceType
+  getMediaSourceType,
 };
 //# sourceMappingURL=index.js.map
